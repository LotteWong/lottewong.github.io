<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LotteWong</title>
  
  <subtitle>在代码符号表象中避难。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-20T16:34:06.576Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LotteWong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>#Others# 和新项目相爱相杀</title>
    <link href="http://yoursite.com/2021/07/21/%E5%92%8C%E6%96%B0%E9%A1%B9%E7%9B%AE%E7%9B%B8%E7%88%B1%E7%9B%B8%E6%9D%80/"/>
    <id>http://yoursite.com/2021/07/21/%E5%92%8C%E6%96%B0%E9%A1%B9%E7%9B%AE%E7%9B%B8%E7%88%B1%E7%9B%B8%E6%9D%80/</id>
    <published>2021-07-20T16:07:21.000Z</published>
    <updated>2021-07-20T16:34:06.576Z</updated>
    
    <content type="html"><![CDATA[<p>夸张的修辞手法.jpg（笑</p><hr><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><blockquote><p>来你🐧正式打工不知不觉已经一周了，比起实习的时候工作内容已经大有不同，再见已是工具人小黄bot（此工具人非彼工具人thx。</p><p>今天主要记录一下理解和熟悉新项目的过程，希望在未来接触新业务也会有所帮助。</p></blockquote><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a><strong>前置条件</strong></h1><blockquote><p>本人司职 <code>Golang</code> 后台开发，下面内容仅供参考。</p></blockquote><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><ol><li><code>Golang</code>：业务开发的主要语言</li><li><code>Shell</code>：工具运维的主要语言</li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><code>Git</code>、<code>Linux</code></li><li>云计算、高并发、分布式、微服务</li><li>算法分析、数据结构</li><li>计算机网络、操作系统、数据库概论</li><li>设计模式、软件架构</li><li>敏捷开发、项目管理</li></ol><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><ol><li><code>gin</code>：基于 API</li><li><code>go-micro</code>：基于微服务</li></ol><h2 id="数据库操作及驱动"><a href="#数据库操作及驱动" class="headerlink" title="数据库操作及驱动"></a>数据库操作及驱动</h2><ol><li><code>MySQL</code>：关系型数据库</li><li><code>MongoDB</code>：文档型数据库</li><li><code>Redis</code>：键值型数据库</li></ol><h2 id="相关系统"><a href="#相关系统" class="headerlink" title="相关系统"></a>相关系统</h2><ol><li><code>upstream</code>：对接内部产品</li><li><code>downstream</code>：前端项目</li></ol><h2 id="迭代流程"><a href="#迭代流程" class="headerlink" title="迭代流程"></a>迭代流程</h2><ol><li><code>Unit Test</code>、<code>Mock Test</code></li><li><code>Coding Standard</code></li><li><code>CI / CD</code></li></ol><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h1><blockquote><p>需求分析阶段主要是从需求层面来了解项目，<strong>知道项目在做什么</strong>。</p></blockquote><h2 id="可用资产"><a href="#可用资产" class="headerlink" title="可用资产"></a>可用资产</h2><ol><li>产品手册</li><li>产品原型</li><li>需求文档</li></ol><h2 id="阶段目标"><a href="#阶段目标" class="headerlink" title="阶段目标"></a>阶段目标</h2><ol><li>理解和区分关键的<strong>领域概念</strong></li><li>明确产品的<strong>主要功能和主要流程</strong></li></ol><h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a><strong>方案设计</strong></h1><blockquote><p>方案设计阶段主要是从方案层面来解构项目，<strong>思考项目该怎么做</strong>。</p></blockquote><h2 id="可用资产-1"><a href="#可用资产-1" class="headerlink" title="可用资产"></a>可用资产</h2><ol><li>技术文档</li><li>接口文档</li><li>数据库表</li></ol><h2 id="阶段目标-1"><a href="#阶段目标-1" class="headerlink" title="阶段目标"></a>阶段目标</h2><ol><li>整理项目的<strong>整体设计</strong>（项目本身），包括功能、架构和流程</li><li>整理项目的<strong>局部设计</strong>（对应特定场景的具体解决方案），包括功能、架构和流程</li><li>了解<strong>接口文档（<code>dto</code>）</strong>如何与业务相结合起来</li><li>了解<strong>数据库表（<code>po</code>）</strong>如何与业务相结合起来</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h1><blockquote><p>代码实现阶段主要是从代码层面来落实项目，<strong>有依据地搞好细节</strong>。</p></blockquote><h2 id="可用资产-2"><a href="#可用资产-2" class="headerlink" title="可用资产"></a>可用资产</h2><ol><li>项目代码</li></ol><h2 id="阶段目标-2"><a href="#阶段目标-2" class="headerlink" title="阶段目标"></a>阶段目标</h2><ol><li><strong>梳理项目代码层次</strong>，比如 <code>router</code>、<code>api controller/cron job/message queue</code>、<code>service</code>、<code>dao/driver</code> 等等</li><li>对应需求和方案，从 <code>api controller/cron job/message queue</code> 来入手，<strong>巩固理解业务，了解实现细节</strong></li><li>遇到<strong>复杂且核心的代码</strong>，可画流程图等专门记录和分析</li></ol><h1 id="模拟开发"><a href="#模拟开发" class="headerlink" title="模拟开发"></a><strong>模拟开发</strong></h1><blockquote><p>模拟开发阶段主要是从实践层面来运行项目，<strong>过一遍工作的流程</strong>。</p></blockquote><h2 id="可用资产-3"><a href="#可用资产-3" class="headerlink" title="可用资产"></a>可用资产</h2><ol><li>项目代码</li><li>环境信息</li></ol><h2 id="阶段目标-3"><a href="#阶段目标-3" class="headerlink" title="阶段目标"></a>阶段目标</h2><ol><li>本地和远程可以<strong>跑通项目代码</strong></li><li><strong>熟悉完整的开发流程</strong>：编写文档 → 生成代码 → 业务开发 → 单元测试 → 代码规范 → 提交代码 → 代码评审 → 合入代码 → 代码打包 → 部署 → 测试</li></ol><h1 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a><strong>代码重构</strong></h1><blockquote><p>代码重构阶段主要是从理想层面来优化项目，<strong>提升自己和新项目</strong>。</p></blockquote><h2 id="可用资产-4"><a href="#可用资产-4" class="headerlink" title="可用资产"></a>可用资产</h2><ol><li>项目代码</li></ol><h2 id="阶段目标-4"><a href="#阶段目标-4" class="headerlink" title="阶段目标"></a>阶段目标</h2><ol><li><strong>学习或改进</strong>项目代码，大到架构模式，小到算法结构，同时也要关注代码规范</li></ol><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a><strong>致谢</strong></h1><blockquote><p>感谢晓清哥成为我的伯乐，让我有机会在喜欢的地方做喜欢的事情，在工作中和生活上也给了我很多鼓励；感谢风哥在我回来之后依然让我觉得对这里很有归属感，风哥也会一直是我的榜样（in every aspect；感谢远哥，亦师亦友，为全世界坠好的 mentor 打call；感谢各位不嫌弃我太菜的同事，有你们在，有风哥选的 mbp，有智神送的 Windows，每天到了工位都觉得这一刻一定要为 HK0700 卖命（bushi。</p><p>上一次分别时，其实自己感到蛮有压力，一方面担心要被炒鱿鱼了（现在也，另一方面是因为有偶像包袱（xs开始给自己加戏。<strong>但是无论如何地说，我最应该做的就是——好好工作</strong>。在热爱的事业里实现价值（我最好是，同时也希望大家因为我的存在而感到开心（一丢丢也行，btw愿下一次没有分别 :)</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;夸张的修辞手法.jpg（笑&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Others" scheme="http://yoursite.com/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>#Kubernetes# QCloud上的Kubernetes初体验</title>
    <link href="http://yoursite.com/2021/06/20/QCloud%E4%B8%8A%E7%9A%84Kubernetes%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2021/06/20/QCloud%E4%B8%8A%E7%9A%84Kubernetes%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-06-19T23:00:21.000Z</published>
    <updated>2021-06-25T07:04:45.616Z</updated>
    
    <content type="html"><![CDATA[<p>在<strong>QCloud</strong>上利用<strong>Kubernetes</strong>编排应用与服务，主要分为以下<strong>四个部分</strong>：</p><ul><li><strong>环境准备 Environment</strong></li><li><strong>疑难解决 FAQ</strong></li><li>具体案例 Cases</li><li>参考文献 References</li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="环境准备-Environment"><a href="#环境准备-Environment" class="headerlink" title="环境准备 Environment"></a><strong>环境准备 Environment</strong></h2><h3 id="更新系统源和软件包"><a href="#更新系统源和软件包" class="headerlink" title="更新系统源和软件包"></a>更新系统源和软件包</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h3 id="修改Docker配置"><a href="#修改Docker配置" class="headerlink" title="修改Docker配置"></a>修改Docker配置</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 编辑docker配置</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-string">"exe-opts"</span>: [<span class="hljs-string">"native.cgroupdriver=systemd"</span>], <span class="hljs-comment"># 修改cgroup driver选项，使docker和k8s一致</span></span><br><span class="line">  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://registry.docker-cn.com"</span>] <span class="hljs-comment"># 替换成国内镜像源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 重启docker服务</span></span><br><span class="line">service docker restart 或 systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="安装Kubernetes工具"><a href="#安装Kubernetes工具" class="headerlink" title="安装Kubernetes工具"></a>安装Kubernetes工具</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 安装依赖工具</span></span><br><span class="line">apt-get install -y apt-transport-https</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 获取阿里云镜像源密钥</span></span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">"deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main"</span> &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 安装k8s工具</span></span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h3 id="下载Kubernetes镜像"><a href="#下载Kubernetes镜像" class="headerlink" title="下载Kubernetes镜像"></a>下载Kubernetes镜像</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 查看所需镜像列表</span></span><br><span class="line">kubeadm config images list</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 编辑下载镜像文件</span></span><br><span class="line">vim pull_k8s_images.sh</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 从国内镜像源中下载镜像并替换标签</span></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  `kubeadm config images list`;  <span class="hljs-keyword">do</span></span><br><span class="line">    imageName=<span class="hljs-variable">$&#123;i#k8s.gcr.io/&#125;</span></span><br><span class="line">    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$imageName</span> != <span class="hljs-string">"coredns/coredns:v1.8.0"</span> ]</span><br><span class="line">    <span class="hljs-keyword">then</span></span><br><span class="line">        docker pull registry.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span></span><br><span class="line">        docker tag registry.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span> k8s.gcr.io/<span class="hljs-variable">$imageName</span></span><br><span class="line">        docker rmi registry.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span></span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        docker pull coredns/coredns:1.8.0</span><br><span class="line">        docker tag coredns/coredns:1.8.0 k8s.gcr.io/<span class="hljs-variable">$imageName</span></span><br><span class="line">        docker rmi coredns/coredns:1.8.0</span><br><span class="line">    <span class="hljs-keyword">fi</span></span><br><span class="line"><span class="hljs-keyword">done</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化Kubernetes主节点"><a href="#初始化Kubernetes主节点" class="headerlink" title="初始化Kubernetes主节点"></a>初始化Kubernetes主节点</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16 <span class="hljs-comment"># 设置网络信息</span></span><br><span class="line">--ignore-preflight-errors=NumCPU <span class="hljs-comment"># 允许单核运行</span></span><br></pre></td></tr></table></figure><h3 id="应用Kubernetes配置"><a href="#应用Kubernetes配置" class="headerlink" title="应用Kubernetes配置"></a>应用Kubernetes配置</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="hljs-variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="hljs-built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><h3 id="下载Kubernetes网络插件"><a href="#下载Kubernetes网络插件" class="headerlink" title="下载Kubernetes网络插件"></a>下载Kubernetes网络插件</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><h3 id="允许主节点部署"><a href="#允许主节点部署" class="headerlink" title="允许主节点部署"></a>允许主节点部署</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><h3 id="允许命令行补全"><a href="#允许命令行补全" class="headerlink" title="允许命令行补全"></a>允许命令行补全</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install bash-completion</span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="查看是否部署成功"><a href="#查看是否部署成功" class="headerlink" title="查看是否部署成功"></a>查看是否部署成功</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><h2 id="疑难解决-FAQ"><a href="#疑难解决-FAQ" class="headerlink" title="疑难解决 FAQ"></a><strong>疑难解决 FAQ</strong></h2><h3 id="Docker重启服务出现异常"><a href="#Docker重启服务出现异常" class="headerlink" title="Docker重启服务出现异常"></a>Docker重启服务出现异常</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 查看日志定位原因</span></span><br><span class="line">service docker status 或 systemctl status docker</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 是因为/var/run/docker.sock出错了</span></span><br><span class="line">level=fatal msg=<span class="hljs-string">"can't create unix socket /var/run/docker.sock: is a directory"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 删除/var/run/docker.sock文件</span></span><br><span class="line">rm -rf /var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 重启docker服务</span></span><br><span class="line">service docker restart 或 systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="Kubernetes忘记加入集群命令"><a href="#Kubernetes忘记加入集群命令" class="headerlink" title="Kubernetes忘记加入集群命令"></a>Kubernetes忘记加入集群命令</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 提示的命令</span></span><br><span class="line">kubeadm join <span class="hljs-variable">$&#123;ip&#125;</span> --token <span class="hljs-variable">$&#123;token&#125;</span> --discovery-token-ca-cert-hash <span class="hljs-variable">$&#123;discovery-token-ca-cert-hash&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 找回的命令</span></span><br><span class="line">kubeadm token create --<span class="hljs-built_in">print</span>-join-command</span><br></pre></td></tr></table></figure><h3 id="x509-certificate-signed-by-unknown-authority"><a href="#x509-certificate-signed-by-unknown-authority" class="headerlink" title="x509: certificate signed by unknown authority"></a>x509: certificate signed by unknown authority</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 重装后.kube/config变化了，重新应用配置</span></span><br><span class="line">mkdir -p <span class="hljs-variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="hljs-built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><h3 id="Docker容器连接本机MySQL-Redis"><a href="#Docker容器连接本机MySQL-Redis" class="headerlink" title="Docker容器连接本机MySQL/Redis"></a>Docker容器连接本机MySQL/Redis</h3><h4 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h4><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 查看docker容器网络模式</span></span><br><span class="line">docker inspect <span class="hljs-variable">$&#123;container_id&#125;</span> | grep -i <span class="hljs-string">"network"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 默认为bridge的模式</span></span><br><span class="line"><span class="hljs-string">"NetworkMode"</span>: <span class="hljs-string">"bridge"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 此时localhost仅仅指的是容器自身地址，应使用主机的内网地址</span></span><br></pre></td></tr></table></figure><h4 id="Host模式"><a href="#Host模式" class="headerlink" title="Host模式"></a>Host模式</h4><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 以host的模式启动docker容器</span></span><br><span class="line">docker run -d --network=host <span class="hljs-variable">$&#123;registry&#125;</span>:<span class="hljs-variable">$&#123;tag&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 此时localhost同时代表了容器和主机的地址</span></span><br></pre></td></tr></table></figure><h3 id="Xshell外网远程访问MySQL-Redis"><a href="#Xshell外网远程访问MySQL-Redis" class="headerlink" title="Xshell外网远程访问MySQL/Redis"></a>Xshell外网远程访问MySQL/Redis</h3><h4 id="修改-MySQL-Redis-配置"><a href="#修改-MySQL-Redis-配置" class="headerlink" title="修改 MySQL/Redis 配置"></a>修改 MySQL/Redis 配置</h4><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 编辑mysql配置</span></span><br><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 监听所有网段</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="hljs-built_in">bind</span>-address=0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 修改远程登录权限</span></span><br><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user <span class="hljs-built_in">set</span> host=<span class="hljs-string">'%'</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 重启mysql服务使其重新生效</span></span><br><span class="line">mysqld --defaults-file=/etc/mysql/my.cnf</span><br><span class="line">service mysql restart 或 systemctl restart mysql</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 编辑redis配置</span></span><br><span class="line">vim /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 监听所有网段</span></span><br><span class="line"><span class="hljs-built_in">bind</span> 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 重启redis-server服务使其重新生效</span></span><br><span class="line">redis-server /etc/redis/redis.conf</span><br><span class="line">service redis-server restart 或 systemctl restart redis-server</span><br></pre></td></tr></table></figure><h4 id="修改腾讯云服务器安全组规则"><a href="#修改腾讯云服务器安全组规则" class="headerlink" title="修改腾讯云服务器安全组规则"></a>修改腾讯云服务器安全组规则</h4><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 允许所有网段访问3306和6379这两个端口</span></span><br><span class="line">0.0.0.0/0 TCP:3306,6379 Allow <span class="hljs-comment"># ipv4放行</span></span><br><span class="line">::/0 TCP:3306,6379 Allow <span class="hljs-comment"># ipv6放行</span></span><br></pre></td></tr></table></figure><h2 id="具体案例-Cases"><a href="#具体案例-Cases" class="headerlink" title="具体案例 Cases"></a><strong>具体案例 Cases</strong></h2><h3 id="交叉编译与镜像构建"><a href="#交叉编译与镜像构建" class="headerlink" title="交叉编译与镜像构建"></a>交叉编译与镜像构建</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># set go env</span></span><br><span class="line"><span class="hljs-built_in">export</span> GO111MODULE=auto</span><br><span class="line"><span class="hljs-built_in">export</span> GOPROXY=https://goproxy.io,direct</span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># build binary executable</span></span><br><span class="line">mkdir -p ./bin</span><br><span class="line">GOOS=linux GOARCH=amd64 go build -o ./bin/giotto_gateway_core</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Dockerfile</span></span><br><span class="line">FROM golang</span><br><span class="line">MAINTAINER LotteWong &lt;lottewong21@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/app</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">CMD ./bin/giotto_gateway_core -config ./configs/prod/</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># docker build</span></span><br><span class="line">commit=`git rev-parse --short HEAD`</span><br><span class="line">docker build -f ./ci/docker/Dockerfile -t giotto-gateway-core:<span class="hljs-variable">$commit</span> .</span><br></pre></td></tr></table></figure><h3 id="容器部署与容器编排"><a href="#容器部署与容器编排" class="headerlink" title="容器部署与容器编排"></a>容器部署与容器编排</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># deploy config</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: giotto-gateway-core</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: giotto-gateway-core</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: giotto-gateway-core</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: giotto-gateway-core</span><br><span class="line">          image: giotto-gateway-core:d1785da</span><br><span class="line">          imagePullPolicy: Never</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">            - containerPort: 443</span><br><span class="line">---</span><br><span class="line"><span class="hljs-comment"># service config</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: giotto-gateway-core</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      name: <span class="hljs-string">"http-proxy"</span></span><br><span class="line">      targetPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">      nodePort: 30080</span><br><span class="line">    - port: 443</span><br><span class="line">      name: <span class="hljs-string">"https-proxy"</span></span><br><span class="line">      targetPort: 443</span><br><span class="line">      protocol: TCP</span><br><span class="line">      nodePort: 30443</span><br><span class="line">  <span class="hljs-built_in">type</span>: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    name: giotto-gateway-core</span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment"># kubectl create</span></span><br><span class="line">kubectl create -f ./ci/k8s/core.yaml</span><br></pre></td></tr></table></figure><h2 id="参考资料-References"><a href="#参考资料-References" class="headerlink" title="参考资料 References"></a><strong>参考资料 References</strong></h2><ol><li><a href="https://cloud.tencent.com/developer/article/1817826" target="_blank" rel="noopener">在 Ubuntu 上安装 K8S 教程</a></li><li><a href="https://my.oschina.net/u/4409146/blog/3306898" target="_blank" rel="noopener">ubuntu k8s 单节点快速安装</a></li><li><a href="https://blog.csdn.net/u012891504/article/details/52857682" target="_blank" rel="noopener">docker服务启动失败</a></li><li><a href="https://blog.csdn.net/weixin_44130081/article/details/103563392" target="_blank" rel="noopener">K8S在kubeadm init以后查询kubeadm join</a></li><li><a href="https://stackoverflow.com/questions/36939381/x509-certificate-signed-by-unknown-authority-kubernetes" target="_blank" rel="noopener">x509 certificate signed by unknown authority- Kubernetes</a></li><li><a href="https://blog.csdn.net/suchahaerkang/article/details/84570488" target="_blank" rel="noopener">Docker的四种网络模式Bridge模式</a></li><li><a href="https://cloud.tencent.com/developer/article/1153843" target="_blank" rel="noopener">mysql 远程连接数据库的二种方法</a></li><li><a href="https://blog.csdn.net/Light_Breeze/article/details/82070222" target="_blank" rel="noopener">解决mysql不用密码也能登录</a></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;strong&gt;QCloud&lt;/strong&gt;上利用&lt;strong&gt;Kubernetes&lt;/strong&gt;编排应用与服务，主要分为以下&lt;strong&gt;四个部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;环境准备 Environment&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;疑难解决 FAQ&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;具体案例 Cases&lt;/li&gt;
&lt;li&gt;参考文献 References&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="DevOps" scheme="http://yoursite.com/categories/DevOps/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 微服务API网关的设计与实现(6) 系统测试</title>
    <link href="http://yoursite.com/2021/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(6)/"/>
    <id>http://yoursite.com/2021/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(6)/</id>
    <published>2021-06-04T23:00:21.000Z</published>
    <updated>2021-06-21T03:11:42.222Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<u>微服务API网关</u>的<strong>系统测试</strong>，分为<strong>两个</strong>方面：</p><ul><li>功能测试</li><li>性能测试</li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a><strong>功能测试</strong></h2><h3 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h3><ul><li><a href="https://segmentfault.com/a/1190000012127784" target="_blank" rel="noopener">常见测试用例设计方法</a></li></ul><h3 id="用例记录"><a href="#用例记录" class="headerlink" title="用例记录"></a>用例记录</h3><table><thead><tr><th align="center">条目</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">用例编号</td><td align="center"><code>[数学]</code></td></tr><tr><td align="center">功能描述</td><td align="center"><code>[-]</code></td></tr><tr><td align="center">前置条件</td><td align="center"><code>[-]</code></td></tr><tr><td align="center">测试过程</td><td align="center"><code>[-]</code></td></tr><tr><td align="center">预期结果</td><td align="center"><code>[-]</code></td></tr><tr><td align="center">是否通过</td><td align="center"><code>[是否]</code></td></tr></tbody></table><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><strong>性能测试</strong></h2><h3 id="测试环境及工具"><a href="#测试环境及工具" class="headerlink" title="测试环境及工具"></a>测试环境及工具</h3><table><thead><tr><th align="center">条目</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">硬件机器配置</td><td align="center">腾讯云服务器1C2G1M</td></tr><tr><td align="center">测试网络环境</td><td align="center">localhost</td></tr><tr><td align="center">软件压测工具</td><td align="center">wrk</td></tr></tbody></table><p><img src="/images/wrk.png" alt="压测工具wrk使用方法"></p><h3 id="测试过程及结果"><a href="#测试过程及结果" class="headerlink" title="测试过程及结果"></a>测试过程及结果</h3><table><thead><tr><th align="center">压测对象</th><th align="center">压测命令</th><th align="center">每秒的请求量</th></tr></thead><tbody><tr><td align="center">微服务API网关核心模块</td><td align="center"><code>wrk -t30 -c600 -d30s -H&quot;Authorization:Bearer ${jwt}&quot; http://localhost:8080/wrk</code></td><td align="center">5651.29</td></tr><tr><td align="center">纯 <code>Golang</code> 服务器</td><td align="center"><code>wrk -t30 -c600 -d30s http://localhost:8081/wrk</code></td><td align="center">25961.68</td></tr><tr><td align="center"><code>Nginx</code></td><td align="center"><code>wrk -t30 -c600 -d30s http://localhost:8082/wrk</code></td><td align="center">3561.78</td></tr></tbody></table><ul><li>开启<strong>30个线程</strong>，并发请求<strong>600次后台接口</strong>，持续<strong>30秒时间</strong>，采集并打印压测结果。</li><li>从<strong>每秒的请求量</strong>看，<strong>纯 <code>Golang</code> 服务器</strong>没有中间流程损耗和额外组件开销因而支撑的 <code>QPS</code> 大幅领先，<strong>微服务API网关核心模块</strong>能够超过未调优前的 <strong><code>Nginx</code></strong> 的性能表现。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;u&gt;微服务API网关&lt;/u&gt;的&lt;strong&gt;系统测试&lt;/strong&gt;，分为&lt;strong&gt;两个&lt;/strong&gt;方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能测试&lt;/li&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 微服务API网关的设计与实现(5) 容器部署</title>
    <link href="http://yoursite.com/2021/06/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(5)/"/>
    <id>http://yoursite.com/2021/06/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(5)/</id>
    <published>2021-06-03T23:00:21.000Z</published>
    <updated>2021-06-20T14:10:45.635Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<u>微服务API网关</u>的<strong>容器部署</strong>，分为<strong>三个</strong>方面：</p><ul><li><code>Golang</code> 交叉编译</li><li><code>Docker</code> 镜像构建</li><li><code>Kubernetes</code> 容器编排</li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="Golang交叉编译"><a href="#Golang交叉编译" class="headerlink" title="Golang交叉编译"></a><strong>Golang交叉编译</strong></h2><ul><li><u><code>Golang</code> 支持交叉编译，即在当前的操作系统和体系架构上生成指定的操作系统和体系架构的可执行程序。</u>微服务API网关预先采取 <code>Golang</code> 交叉编译出于两点考虑：一是提前在开发环境中编译程序比之后在镜像构建中编译程序的<strong>速度要更加快</strong>；二是开发环境和部署环境的操作系统不同，可执行的二进制文件必须经过交叉编译<strong>才能正常运行</strong>。</li></ul><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># take giotto-gateway-core as an example</span></span><br><span class="line"><span class="hljs-comment"># https://github.com/LotteWong/giotto-gateway-core/blob/main/ci/docker/cross_compile.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># set go env</span></span><br><span class="line"><span class="hljs-built_in">export</span> GO111MODULE=auto</span><br><span class="line"><span class="hljs-built_in">export</span> GOPROXY=https://goproxy.io,direct</span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># build binary executable</span></span><br><span class="line">mkdir -p ./bin</span><br><span class="line">GOOS=linux GOARCH=amd64 go build -o ./bin/giotto_gateway_core</span><br></pre></td></tr></table></figure><ul><li>先设置 <code>Golang</code> 打开 <code>Go Module</code> 模式并下载程序的模块依赖，再定义目标的操作系统和体系架构开始交叉编译。</li></ul><h2 id="Docker镜像构建"><a href="#Docker镜像构建" class="headerlink" title="Docker镜像构建"></a><strong>Docker镜像构建</strong></h2><ul><li><u><code>Docker</code> 是一个通过管理 <code>Linux</code> 容器来实现应用环境隔离的开源容器引擎，它提供了一整套完备且易用的容器管理接口。</u>微服务API网关的管理模块和核心模块两个微服务将使用 <code>Docker</code> 构建镜像，实现<strong>更快的程序部署和更低的计算开销</strong>。</li></ul><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># take giotto-gateway-core as an example</span></span><br><span class="line"><span class="hljs-comment"># https://github.com/LotteWong/giotto-gateway-core/blob/main/ci/docker/Dockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">FROM</span> golang</span><br><span class="line"><span class="hljs-keyword">MAINTAINER</span> LotteWong &lt;lottewong21@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">WORKDIR</span><span class="hljs-bash"> /go/src/app</span></span><br><span class="line"><span class="hljs-keyword">COPY</span><span class="hljs-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CMD</span><span class="hljs-bash"> ./bin/giotto_gateway_core -config ./configs/prod/</span></span><br></pre></td></tr></table></figure><ul><li>先拉取基础镜像 <code>golang</code>，再定义容器内的工作目录为 <code>/go/src/app</code>，接着将主机的源文件拷贝进容器中，最后命令行启动微服务。</li></ul><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># take giotto-gateway-core as an example</span></span><br><span class="line"><span class="hljs-comment"># https://github.com/LotteWong/giotto-gateway-core/blob/main/ci/docker/cross_compile.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># build docker images</span></span><br><span class="line">commit=`git rev-parse --short HEAD`</span><br><span class="line">docker build -f ./ci/docker/Dockerfile -t giotto-gateway-core:<span class="hljs-variable">$commit</span> .</span><br></pre></td></tr></table></figure><ul><li>先读取 <code>Git</code> 版本管理库中最新的 <code>commit id</code> 作为镜像的 <code>tag</code>，以便更好地标识和管理镜像，再使用 <code>docker build</code> 命令，传入参数构建镜像。</li></ul><h2 id="Kubernetes容器编排"><a href="#Kubernetes容器编排" class="headerlink" title="Kubernetes容器编排"></a><strong>Kubernetes容器编排</strong></h2><ul><li><u><code>Kubernetes</code> 是具备良好的自动化部署、扩展、调度和编排能力的开源容器管理平台，能够帮助有效地降低容器运维成本，提高服务集群管理效率。</u>微服务API网关的管理模块和核心模块两个微服务将使用 <code>Kubernetes</code> 部署和编排容器，以提高系统的<strong>扩展性和可靠性</strong>。</li></ul><p><img src="/images/microservice_api_gateway_k8s.png" alt="微服务API网关基于Kubernetes的部署图"></p><ul><li>对于<u>核心模块</u>而言，1个核心模块 <code>Pod</code> 管理1个核心模块 <code>Container</code> 的<strong>生命周期</strong>，总共部署3个 <code>Pod</code> 实现核心模块功能的<strong>高可用</strong>；对于<u>管理模块</u>而言，1个管理模块 <code>Pod</code> 管理1个管理模块 <code>Container</code> 的<strong>生命周期</strong>，由于到达管理模块的流量相对较小，总共部署1个 <code>Pod</code> <strong>提供服务</strong>。创建 <code>Deployment</code> 用于对 <code>Pod</code> 进行<strong>弹性伸缩和负载均衡</strong>，创建 <code>Service</code> 用于对 <code>Pod</code> 进行端口映射以<strong>实现外部网络的访问</strong>。</li></ul><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># take giotto-gateway-core as an example</span></span><br><span class="line"><span class="hljs-comment"># https://github.com/LotteWong/giotto-gateway-core/blob/main/ci/k8s/core.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># deploy config</span></span><br><span class="line"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span></span><br><span class="line"><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span></span><br><span class="line"><span class="hljs-attr">metadata:</span></span><br><span class="line">  <span class="hljs-attr">name:</span> <span class="hljs-string">giotto-gateway-core</span></span><br><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line">  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line">  <span class="hljs-attr">selector:</span></span><br><span class="line">    <span class="hljs-attr">matchLabels:</span></span><br><span class="line">      <span class="hljs-attr">name:</span> <span class="hljs-string">giotto-gateway-core</span></span><br><span class="line">  <span class="hljs-attr">template:</span></span><br><span class="line">    <span class="hljs-attr">metadata:</span></span><br><span class="line">      <span class="hljs-attr">labels:</span></span><br><span class="line">        <span class="hljs-attr">name:</span> <span class="hljs-string">giotto-gateway-core</span></span><br><span class="line">    <span class="hljs-attr">spec:</span></span><br><span class="line">      <span class="hljs-attr">containers:</span></span><br><span class="line">        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">giotto-gateway-core</span></span><br><span class="line">          <span class="hljs-attr">image:</span> <span class="hljs-string">giotto-gateway-core:d1785da</span></span><br><span class="line">          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Never</span></span><br><span class="line">          <span class="hljs-attr">ports:</span></span><br><span class="line">            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span></span><br><span class="line">            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span></span><br></pre></td></tr></table></figure><ul><li><code>Kubernetes Deployment</code> 配置定义了 <code>Pod</code> 的副本数量、元数据、容器镜像和容器端口映射关系等，用于对微服务容器进行部署运行、弹性伸缩和负载均衡。</li></ul><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># take giotto-gateway-core as an example</span></span><br><span class="line"><span class="hljs-comment"># https://github.com/LotteWong/giotto-gateway-core/blob/main/ci/k8s/core.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># service config</span></span><br><span class="line"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span></span><br><span class="line"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span></span><br><span class="line"><span class="hljs-attr">metadata:</span></span><br><span class="line">  <span class="hljs-attr">name:</span> <span class="hljs-string">giotto-gateway-core</span></span><br><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line">  <span class="hljs-attr">ports:</span></span><br><span class="line">    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span></span><br><span class="line">      <span class="hljs-attr">name:</span> <span class="hljs-string">"http-proxy"</span></span><br><span class="line">      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span></span><br><span class="line">      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span></span><br><span class="line">      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30080</span></span><br><span class="line">    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">443</span></span><br><span class="line">      <span class="hljs-attr">name:</span> <span class="hljs-string">"https-proxy"</span></span><br><span class="line">      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">443</span></span><br><span class="line">      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span></span><br><span class="line">      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30443</span></span><br><span class="line">  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span></span><br><span class="line">  <span class="hljs-attr">selector:</span></span><br><span class="line">    <span class="hljs-attr">name:</span> <span class="hljs-string">giotto-gateway-core</span></span><br></pre></td></tr></table></figure><ul><li><code>Kubernetes Service</code> 配置定义了元数据和对外端口映射关系等，用于建立外部网络访问 <code>Kubernetes</code> 节点内容器的通信桥梁。</li></ul><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># take giotto-gateway-core as an example</span></span><br><span class="line"><span class="hljs-comment"># https://github.com/LotteWong/giotto-gateway-core/blob/main/ci/k8s/apply_yaml.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># k8s apply yaml to create deploy and service</span></span><br><span class="line">kubectl create -f ./ci/k8s/core.yaml</span><br></pre></td></tr></table></figure><ul><li>使用 <code>kubectl create</code> 命令，传入配置文件路径创建 <code>Deployment</code> 和 <code>Service</code>。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;u&gt;微服务API网关&lt;/u&gt;的&lt;strong&gt;容器部署&lt;/strong&gt;，分为&lt;strong&gt;三个&lt;/strong&gt;方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Golang&lt;/code&gt; 交叉编译&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Docker&lt;/code&gt; 镜像构建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kubernetes&lt;/code&gt; 容器编排&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
    <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 微服务API网关的设计与实现(3) 微服务设计</title>
    <link href="http://yoursite.com/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(3)/"/>
    <id>http://yoursite.com/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(3)/</id>
    <published>2021-06-02T23:00:21.000Z</published>
    <updated>2021-06-18T08:18:18.511Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<u>微服务API网关</u>的<strong>微服务设计</strong>，分为<strong>两个</strong>方面：</p><ul><li>微服务API网关管理模块设计 - <strong>时序图</strong></li><li>微服务API网关核心模块设计 - <strong>时序图</strong></li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a><strong>UML</strong></h2><ul><li><u>时序图</u>一般由<strong>角色、对象、生命线、控制焦点、消息和组合片段</strong>构成。</li></ul><h3 id="控制焦点"><a href="#控制焦点" class="headerlink" title="控制焦点"></a>控制焦点</h3><ul><li>控制焦点是时序图中表示时间段的符号，在此时间段内对象将执行相应的操作。</li></ul><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><table><thead><tr><th align="center">消息类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">同步消息</td><td align="center">发送者同步调用接收者，两者顺序工作</td></tr><tr><td align="center">异步消息</td><td align="center">发送者异步调用接收者，两者并发工作</td></tr><tr><td align="center">返回消息</td><td align="center">从调用中返回结果</td></tr><tr><td align="center">自联消息</td><td align="center">调用对象自身方法</td></tr></tbody></table><h3 id="组合片段"><a href="#组合片段" class="headerlink" title="组合片段"></a>组合片段</h3><table><thead><tr><th align="center">组合类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Alternative Fragment (alt)</td><td align="center">相当于 if-else</td></tr><tr><td align="center">Option Fragment (opt)</td><td align="center">相当于 switch-case</td></tr><tr><td align="center">Parallel Fragment (par)</td><td align="center">相当于 go</td></tr><tr><td align="center">Loop Fragment (loop)</td><td align="center">相当于 for</td></tr></tbody></table><h2 id="微服务API网关管理模块设计"><a href="#微服务API网关管理模块设计" class="headerlink" title="微服务API网关管理模块设计"></a><strong>微服务API网关管理模块设计</strong></h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><ul><li>下图是<u>微服务API网关管理模块的架构图</u>，微服务API网关管理模块的内部逻辑是典型的MVC模式，由 <strong><code>UI</code> 层、<code>Router</code> 层、<code>Controller</code> 层和 <code>Dao</code> 层</strong>组成。</li></ul><p><img src="/images/microservice_api_gateway_admin_arch.png" alt="微服务API网关管理模块架构图"></p><ol><li><strong><code>UI</code> 层</strong>即前端可视化的管理平台界面，前端代码被编译打包后，将静态托管于管理模块中。</li><li><strong><code>Router</code> 层</strong>对外暴露API接口，定义了API的请求方法和访问路径，编排了所应用的中间件的类型和顺序。</li><li><strong><code>Controller</code> 层</strong>是具体实现业务逻辑的层次，在该层次进行用户登录、用户登出、管理用户、管理服务、管理应用和数据统计功能的编写。</li><li><strong><code>Dao</code> 层</strong>作为数据库驱动层直接对接不同类型的数据库，管理模块支持对 <code>MySQL</code> 和 <code>Redis</code> 进行操作。</li><li><code>UI</code> 层和 <code>Router</code> 层之间主要传输 <strong><code>json</code></strong> 数据，统一了前后端的数据传输格式；<code>Router</code> 层和 <code>Controller</code> 层之间主要传输程序定义的 <strong><code>dto</code> (数据传输对象)</strong> 结构体；<code>Controller</code> 层和 <code>Dao</code> 层之间主要传输程序定义的 <strong><code>po</code> (持久化对象)</strong> 结构体。</li></ol><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><ul><li>下图是<u>微服务API网关管理模块的时序图</u>，来描述管理员用户如何通过管理模块进行登录登出和各项配置管理。</li></ul><p><img src="/images/microservice_api_gateway_admin_seq.png" alt="微服务API网关管理模块时序图"></p><ol><li><strong>第1步到第2步</strong>，管理员用户需要输入用户名称和用户密码登录，此时登录生成的会话信息将保存到 <code>Redis</code> ，以便保持一定时间内的登录状态。</li><li><strong>第3步到第5步</strong>，管理员用户添加、修改或删除配置，配置的变更将会分别存入到 <code>MySQL</code> 和 <code>Redis</code> 中。</li><li><strong>第6步到第12步</strong>，管理员用户查询配置，若缓存命中则直接从 <code>Redis</code> 中读取配置的缓存数据，若缓存未命中则会从 <code>MySQL</code> 中读取配置的数据库数据，并将配置回写到 <code>Redis</code> 缓存中，然后返回配置给管理员用户。</li><li><strong>第13步到第14步</strong>，当管理员用户登出时，管理模块将删除 <code>Redis</code> 中对应的会话信息，此后该管理员用户的登录状态不再保持，可以选择重新登录或者切换账户登录。</li></ol><h2 id="微服务API网关核心模块设计"><a href="#微服务API网关核心模块设计" class="headerlink" title="微服务API网关核心模块设计"></a><strong>微服务API网关核心模块设计</strong></h2><h3 id="架构图-1"><a href="#架构图-1" class="headerlink" title="架构图"></a>架构图</h3><ul><li>下图是<u>微服务API网关核心模块的架构图</u>，微服务API网关核心模块由多个中间件以洋葱模型的形式组织起来，并与 <code>Redis</code> 和 <code>Consul</code> 结合使用，为不同形态的客户端提供多协议的后台服务统一入口。</li></ul><p><img src="/images/microservice_api_gateway_core_arch.png" alt="微服务API网关核心模块架构图"></p><ol><li><code>App</code> 应用或 <code>Web</code> 应用发起请求，在核心模块中经过协议接入、权限认证、流量统计、流量控制、请求重写、负载均衡和反向代理中间件的处理，最终到达后台的 <code>HTTP</code> 服务、<code>HTTPS</code> 服务或 <code>WebSocket</code> 服务。</li><li>其中，后台的服务应预先配置好服务和应用的配置，方便核心模块的协议接入中间件和权限认证中间件读取服务和应用的配置进而处理后续的业务逻辑。同时，后台的服务也应先在 <code>Consul</code> 中注册服务名称和地址，方便核心模块的负载均衡中间件发现服务地址，根据权重列表设置和负载均衡算法合理分发流量，最后交由反向代理中间件去访问实际的后台服务。</li><li>特别地，在核心模块中应该保持对服务地址变化的监听，<code>Consul</code> 也有必要周期性对后台服务进行健康检查，保证服务的可用性。</li></ol><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><ul><li>下图是<u>微服务API网关核心模块的时序图</u>，来说明应用如何通过核心模块进行公共逻辑处理和请求代理转发。</li></ul><p><img src="/images/microservice_api_gateway_core_seq.png" alt="微服务API网关核心模块时序图"></p><ol><li><strong>第1步</strong>，应用发起请求。</li><li><strong>第2步到第7步</strong>，核心模块先向 <code>Redis</code> 缓存查询服务配置进行协议接入，然后查询应用配置进行权限认证。</li><li><strong>第8步到第11步</strong>，进行流量统计和流量控制，并回写入 <code>Redis</code>。</li><li><strong>第12步</strong>，根据规则进行请求重写。</li><li><strong>第13步到第15步</strong>，根据服务发现获取的地址列表以及预先配置的权重列表应用指定的负载均衡算法选出访问地址。</li><li><strong>第16步到第18步</strong>，核心模块使用负载均衡地址反向代理访问后台服务，并将响应返回给应用。</li></ol><h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a><strong>FAQs</strong></h2><blockquote><p><strong>Q：</strong>并行和异步如何用时序图来表示？</p><p><strong>A：</strong>首先确定触发的时间点，接着判断是否并行，最后判断是否异步</p></blockquote><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a><strong>Refs</strong></h2><ul><li><a href="https://www.cnblogs.com/ywqu/archive/2009/12/22/1629426.html" target="_blank" rel="noopener">UML建模之时序图（Sequence Diagram）</a></li><li><a href="https://blog.csdn.net/craftsman1970/article/details/72629590" target="_blank" rel="noopener">序列图(Sequence Diagram)::并行区/临界区</a></li><li><a href="https://blog.csdn.net/craftsman1970/article/details/71136232" target="_blank" rel="noopener">序列图(Sequence Diagram)::同步/异步</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;u&gt;微服务API网关&lt;/u&gt;的&lt;strong&gt;微服务设计&lt;/strong&gt;，分为&lt;strong&gt;两个&lt;/strong&gt;方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务API网关管理模块设计 - &lt;strong&gt;时序图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;微服务API网关核心模块设计 - &lt;strong&gt;时序图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 微服务API网关的设计与实现(4) 数据库设计</title>
    <link href="http://yoursite.com/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(4)/"/>
    <id>http://yoursite.com/2021/06/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(4)/</id>
    <published>2021-06-02T23:00:21.000Z</published>
    <updated>2021-06-18T13:39:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<u>微服务API网关</u>的<strong>数据库设计</strong>，分为<strong>两个</strong>方面：</p><ul><li><code>MySQL</code> 数据库表设计 - <strong>E-R图及关系模式</strong></li><li><code>Redis</code> 键值设计</li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ul><li>1NF是对属性的<strong>原子性</strong>，要求<strong>属性不可再分解</strong>。</li><li>2NF是对记录的<strong>唯一性</strong>，要求记录有唯一标识，即<strong>不存在部分依赖</strong>。</li><li>3NF是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段中派生出来，即<strong>不存在传递依赖</strong>。</li></ul><h3 id="绘制E-R图例"><a href="#绘制E-R图例" class="headerlink" title="绘制E-R图例"></a>绘制E-R图例</h3><ol><li>确定所有的实体（矩形框）</li><li>确定实体的联系（连线）</li><li>确定实体和联系的属性（椭圆框）</li><li>确定实体的键（下划线）</li></ol><h3 id="转换关系模式"><a href="#转换关系模式" class="headerlink" title="转换关系模式"></a>转换关系模式</h3><table><thead><tr><th align="center">类型</th><th align="center">映射方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">一元联系</td><td align="center">直接映射</td><td align="center">实体的属性→关系模式的属性；实体的主键→关系模式的主键</td></tr><tr><td align="center">二元联系 - 一对一</td><td align="center">合并关系模式</td><td align="center">合成一个关系模式 <strong>R</strong>；任一实体的全部主键→关系模式的主键</td></tr><tr><td align="center">二元联系 - 一对多</td><td align="center">引入外键</td><td align="center">一方实体的主键→多方实体的外键；联系的属性→多方实体的属性</td></tr><tr><td align="center">二元联系 - 多对多</td><td align="center">增加关系模式</td><td align="center">增加一个关系模式 <strong>R</strong>；两个实体的主键并集→关系模式的主键；联系的属性→关系模式的属性</td></tr><tr><td align="center">超类子类</td><td align="center">分化关系模式</td><td align="center">分化两个关系模式 <strong>R1 和 R2</strong>；R1是父关系模式，包括R1主键和R1非主键；R2是子关系模式，包括R1主键和R2非主键；若概括是全部的，不用创建父关系模式，子关系模式包括所有</td></tr><tr><td align="center">复合属性</td><td align="center">由子属性代替</td><td align="center">复合属性 A → 多个子属性代替 A1, A2, A3, …</td></tr><tr><td align="center">多值属性</td><td align="center">拆分关系模式</td><td align="center">拆成两个关系模式 <strong>R1 和 R2</strong>；R1包括R的主键和M的本身；R2包括R的主键和除多值属性外的属性；注意设置级联操作</td></tr></tbody></table><h2 id="MySQL-数据库表设计"><a href="#MySQL-数据库表设计" class="headerlink" title="MySQL 数据库表设计"></a><strong>MySQL 数据库表设计</strong></h2><h3 id="用户的数据库表设计"><a href="#用户的数据库表设计" class="headerlink" title="用户的数据库表设计"></a>用户的数据库表设计</h3><p><img src="/images/user_er.png" alt="用户的E-R图"></p><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><ul><li><u>用户实体</u>拥有<strong>用户ID、用户名称、加密密码和加密盐值</strong>四种属性，其中出于安全性的考虑，密码需要经过盐值加密后存储在数据库而非直接明文存储。</li></ul><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><ul><li>没有联系可以分析。</li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul><li>对用户的E-R图进行一元联系类型转换，得出关系模式：<strong>用户实体的属性为独立的一张表</strong>。</li></ul><h3 id="服务的数据库表设计"><a href="#服务的数据库表设计" class="headerlink" title="服务的数据库表设计"></a>服务的数据库表设计</h3><p><img src="/images/service_er.png" alt="服务的E-R图"></p><h4 id="实体-1"><a href="#实体-1" class="headerlink" title="实体"></a>实体</h4><ul><li><u>服务实体</u>拥有<strong>服务ID、服务名称、服务描述和协议类型</strong>四种属性，其中协议类型是多值属性，用于扩展和适配接入不同协议的服务，目前可支持 <code>HTTP</code>、<code>HTTPS</code> 和 <code>WebSocket</code> 协议。</li><li><u>协议接入与请求重写配置实体</u>固定具有<strong>地址和重写规则</strong>属性，从协议接入与请求重写配置中可以泛化出各种类型的协议配置，不同协议的配置内容不尽相同。</li><li><u>权限认证配置实体</u>包含<strong>ip黑白名单</strong>的属性，用于鉴别请求来源。</li><li><u>流量控制配置实体</u>是相对服务而言的，具有<strong>限流间隔和限流次数</strong>属性，可以支持周期灵活的限流策略。</li><li><u>负载均衡配置实体</u>有三大属性，分别为<strong>ip列表、weight列表和算法类型</strong>，其中算法类型是多值属性，标识了负载均衡使用的算法，目前支持随机负载均衡、轮询负载均衡、加权轮询负载均衡和一致性哈希负载均衡四种算法。</li></ul><h4 id="联系-1"><a href="#联系-1" class="headerlink" title="联系"></a>联系</h4><ul><li>服务实体与协议接入与请求重写配置实体、权限认证配置实体、流量控制配置实体、负载均衡配置实体和反向代理配置实体的关系都是<strong>一对一的拥有关系</strong>。特别地，协议接入配置实体存在<strong>泛化</strong>，可以衍生出不同类型的协议接入与请求重写配置。</li></ul><h4 id="转换-1"><a href="#转换-1" class="headerlink" title="转换"></a>转换</h4><ul><li>对服务的E-R图进行二元联系类型转换，得出关系模式：<strong>服务实体与权限认证配置实体、流量控制配置实体、负载均衡配置实体和反向代理配置实体合并为一张数据库表，为了考虑后续对其他协议进行扩展，故每种协议配置都建议新建一张数据库表</strong>。</li></ul><h3 id="应用的数据库表设计"><a href="#应用的数据库表设计" class="headerlink" title="应用的数据库表设计"></a>应用的数据库表设计</h3><p><img src="/images/app_er.png" alt="应用的E-R图"></p><h4 id="实体-2"><a href="#实体-2" class="headerlink" title="实体"></a>实体</h4><ul><li><u>应用实体</u>拥有<strong>应用ID、应用标识、应用名称和应用密钥</strong>四种属性，其中出于安全性的考虑密钥应该存储加密后的密文而非明文。</li><li><u>权限认证配置实体</u>包含<strong>ip黑白名单</strong>的属性，用于鉴别请求来源。</li><li><u>流量控制配置实体</u>是相对应用而言的，具有<strong>QPD（每日请求量）限制和QPS（每秒请求量）限制</strong>两种属性。</li></ul><h4 id="联系-2"><a href="#联系-2" class="headerlink" title="联系"></a>联系</h4><ul><li>应用实体与权限控制配置实体和流量控制配置实体的关系都是<strong>一对一的拥有关系</strong>。</li></ul><h4 id="转换-2"><a href="#转换-2" class="headerlink" title="转换"></a>转换</h4><ul><li>对应用的E-R图进行二元联系类型转换，得出关系模式：<strong>服务实体与权限认证配置实体和流量控制配置实体合并为一张数据库表</strong>。</li></ul><h2 id="Redis-键值设计"><a href="#Redis-键值设计" class="headerlink" title="Redis 键值设计"></a><strong>Redis 键值设计</strong></h2><h3 id="会话的键值设计"><a href="#会话的键值设计" class="headerlink" title="会话的键值设计"></a>会话的键值设计</h3><table><thead><tr><th align="center">键</th><th align="center">值类型</th><th align="center">值内容</th></tr></thead><tbody><tr><td align="center">session_<code>{session_id}</code></td><td align="center">Binary</td><td align="center">会话信息</td></tr></tbody></table><h3 id="配置的键值设计"><a href="#配置的键值设计" class="headerlink" title="配置的键值设计"></a>配置的键值设计</h3><table><thead><tr><th align="center">键</th><th align="center">值类型</th><th align="center">值内容</th></tr></thead><tbody><tr><td align="center">app_<code>{app_id}</code></td><td align="center">String</td><td align="center">app po as json</td></tr><tr><td align="center">service_<code>{service_id}</code></td><td align="center">String</td><td align="center">service po as json</td></tr><tr><td align="center">lb_<code>{lb_id}</code></td><td align="center">String</td><td align="center">load balance po as json</td></tr><tr><td align="center">ac_<code>{ac_id}</code></td><td align="center">String</td><td align="center">access control po as json</td></tr></tbody></table><h3 id="计数器的键值设计"><a href="#计数器的键值设计" class="headerlink" title="计数器的键值设计"></a>计数器的键值设计</h3><table><thead><tr><th align="center">键</th><th align="center">值类型</th><th align="center">值内容</th></tr></thead><tbody><tr><td align="center">flow_day_count_<code>{day_format}</code>_flow_total_count</td><td align="center">String</td><td align="center">总计每一天的流量统计数</td></tr><tr><td align="center">flow_hour_count_<code>{hour_format}</code>_flow_total_count</td><td align="center">String</td><td align="center">总计每小时的流量统计数</td></tr><tr><td align="center">flow_day_count_<code>{day_format}</code>_flow_service_count_<code>{service_name}</code></td><td align="center">String</td><td align="center">单个服务每一天的流量统计数</td></tr><tr><td align="center">flow_hour_count_<code>{hour_format}</code>_flow_service_count_<code>{service_name}</code></td><td align="center">String</td><td align="center">单个服务每小时的流量统计数</td></tr><tr><td align="center">flow_day_count_<code>{day_format}</code>_flow_app_count_<code>{app_id}</code></td><td align="center">String</td><td align="center">单个应用每一天的流量统计数</td></tr><tr><td align="center">flow_hour_count_<code>{hour_format}</code>_flow_app_count_<code>{app_id}</code></td><td align="center">String</td><td align="center">单个应用每小时的流量统计数</td></tr></tbody></table><h3 id="限流器的键值设计"><a href="#限流器的键值设计" class="headerlink" title="限流器的键值设计"></a>限流器的键值设计</h3><table><thead><tr><th align="center">键</th><th align="center">值类型</th><th align="center">值内容</th></tr></thead><tbody><tr><td align="center">rate_flow_service_count_<code>{service_name}</code></td><td align="center">String</td><td align="center">单个服务调用结束的时间点</td></tr><tr><td align="center">rate_flow_app_count_<code>{app_id}</code></td><td align="center">String</td><td align="center">单个应用调用结束的时间点</td></tr></tbody></table><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a><strong>Refs</strong></h2><ul><li><a href="https://segmentfault.com/a/1190000013695030" target="_blank" rel="noopener">数据库逻辑设计之三大范式通俗理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/29029129#:~:text=er%E5%9B%BE%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%98,%E5%92%8C%E5%90%8D%E5%AD%97%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A&text=%E6%B4%BE%E7%94%9F%E5%B1%9E%E6%80%A7(derivers%20attribute)%EF%BC%9A,%E5%AD%98%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B1%9E%E6%80%A7%E3%80%82" target="_blank" rel="noopener">数据库ER图基础概念整理</a></li><li><a href="https://zhuanlan.zhihu.com/p/74394591" target="_blank" rel="noopener">如何画好ER图</a></li><li><a href="https://www.pianshen.com/article/1262363338/" target="_blank" rel="noopener">将E-R图转换成关系模式</a></li><li><a href="https://lanlan2017.github.io/ReadingNotes/ef76614/" target="_blank" rel="noopener">数据库设计过程</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;u&gt;微服务API网关&lt;/u&gt;的&lt;strong&gt;数据库设计&lt;/strong&gt;，分为&lt;strong&gt;两个&lt;/strong&gt;方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MySQL&lt;/code&gt; 数据库表设计 - &lt;strong&gt;E-R图及关系模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 键值设计&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 微服务API网关的设计与实现(2) 整体设计</title>
    <link href="http://yoursite.com/2021/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(2)/"/>
    <id>http://yoursite.com/2021/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(2)/</id>
    <published>2021-06-01T23:00:21.000Z</published>
    <updated>2021-06-18T07:08:21.131Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<u>微服务API网关</u>的<strong>整体设计</strong>，分为<strong>两个</strong>方面：</p><ul><li>逻辑架构</li><li>调用关系</li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a><strong>逻辑架构</strong></h2><ul><li>下图是<u>微服务API网关的整体逻辑架构图</u>，展示了微服务API网关的组成部分和逻辑功能。微服务API网关由<strong>管理模块</strong>和<strong>核心模块</strong>两个微服务提供主要功能，同时还依赖<strong>服务注册与服务发现中心</strong>提供服务的注册和发现，以及<strong>数据库层</strong>提供数据的缓存和持久化。</li></ul><p><img src="/images/microservice_api_gateway_arch.png" alt="微服务API网关逻辑架构图"></p><ol><li><strong>微服务API网关管理模块</strong>，内置了UI界面层提供可视化的管理平台，请求经由API接口层可以访问用户登录、用户登出、管理服务、管理应用、管理用户和数据统计等功能，实现一站式的网关配置管理。</li><li><strong>微服务API网关核心模块</strong>，由协议接入中间件识别请求和匹配配置，权限认证、请求重写、流量统计和流量控制中间件进行公共业务逻辑处理，负载均衡中间件从服务注册与服务发现中心发现可用服务列表并应用负载均衡算法找出合适的响应实例，反向代理根据负载均衡地址将请求转发至服务端服务并返回响应给客户端应用。</li><li><strong>服务注册与服务发现中心</strong>，技术选型为开箱即用的 <code>Consul</code>，主要提供服务注册和服务发现的功能。对服务端服务而言，提供服务注册的统一存储位置，保存服务的名称、地址、端口和标签等元数据信息，还可以对已注册的服务进行自定义的周期性健康检查。对于微服务API网关而言，负载均衡中间件可以根据服务名发现可用的服务实例地址，并动态监听这些地址的可用情况和状态变化，及时更新负载均衡的地址列表。</li><li><strong>数据库层</strong>，包括 <code>MySQL</code> 关系型数据库和 <code>Redis</code> 非关系型数据库。<code>MySQL</code> 用于持久化用户、服务和应用的信息，是业务数据存放的位置和缓存数据同步的来源。<code>Redis</code> 用作缓存和计数器，加快微服务API网关处理客户端应用请求的速度，实现系统流量的统计和监控，并根据策略控制流量的进出。</li></ol><h2 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a><strong>调用关系</strong></h2><ul><li>下图是<u>微服务API网关的整体调用关系图</u>，展示了微服务API网关各模块及其依赖作为一个整体如何与客户端和服务端进行交互的过程。其中<strong>客户端</strong>由管理员用户、<code>Web/App</code> 应用组成，<strong>微服务API网关</strong>由管理模块、核心模块、<code>MySQL</code>、<code>Redis</code> 和 <code>Consul</code> 组成，<strong>服务端</strong>由微服务组成。</li></ul><p><img src="/images/microservice_api_gateway_call.png" alt="微服务API网关调用关系图"></p><ol><li><strong>第1步</strong>，服务端的微服务先在服务注册与服务发现中心 <code>Consul</code> 中注册该微服务的名称和地址。</li><li><strong>第2步</strong>，客户端的管理员用户在管理模块中配置服务和应用。</li><li><strong>第3步</strong>，配置成功写入 <code>MySQL</code> 关系型数据库和 <code>Redis</code> 非关系型数据库中。</li><li><strong>第4步</strong>，客户端的 <code>Web</code> 应用或 <code>App</code> 应用即可通过核心模块请求服务端的微服务。</li><li><strong>第5步</strong>，核心模块在 <code>Redis</code> 缓存中读取服务和应用的配置。</li><li><strong>第6步</strong>，核心模块在服务注册与服务发现中心 <code>Consul</code> 中获取可用的地址列表。</li><li><strong>第7步</strong>，经过核心模块的一系列公共业务逻辑中间件处理后，请求被反向代理到已注册的微服务，服务端的微服务接收到请求并处理后返回响应给核心模块，核心模块再返回响应给客户端的应用。</li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;u&gt;微服务API网关&lt;/u&gt;的&lt;strong&gt;整体设计&lt;/strong&gt;，分为&lt;strong&gt;两个&lt;/strong&gt;方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑架构&lt;/li&gt;
&lt;li&gt;调用关系&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 微服务API网关的设计与实现(1) 需求分析</title>
    <link href="http://yoursite.com/2021/06/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(1)/"/>
    <id>http://yoursite.com/2021/06/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(1)/</id>
    <published>2021-05-31T23:00:21.000Z</published>
    <updated>2021-06-20T12:45:09.180Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<u>微服务API网关</u>的<strong>需求分析</strong>，分为<strong>两个</strong>方面：</p><ul><li>功能性需求分析 - <strong>用例图和用例表</strong></li><li>非功能性需求分析</li></ul><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a><strong>UML</strong></h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><ul><li><u>用例图</u>一般由<strong>参与者、用例、系统边界和关系</strong>构成。</li></ul><table><thead><tr><th align="center">关系类型</th><th>元素</th><th align="center">说明</th><th align="center">条件性</th><th align="center">直接性</th><th align="center">箭头指向</th></tr></thead><tbody><tr><td align="center">关联</td><td>参与者与用例之间的关系</td><td align="center">参与者和用例通信</td><td align="center">-</td><td align="center">-</td><td align="center">发送方指向接受方</td></tr><tr><td align="center">泛化</td><td>参与者之间或用例之间的关系</td><td align="center">子元素继承父元素</td><td align="center">无</td><td align="center">直接</td><td align="center">子元素指向父元素</td></tr><tr><td align="center">包含</td><td>用例之间的关系</td><td align="center">复杂用例拆成简单用例</td><td align="center">无</td><td align="center">间接</td><td align="center">复杂用例指向简单用例</td></tr><tr><td align="center">扩展</td><td>用例之间的关系</td><td align="center">基础用例增加附加用例</td><td align="center">有</td><td align="center">直接</td><td align="center">基础用例指向附加用例</td></tr></tbody></table><h3 id="用例表"><a href="#用例表" class="headerlink" title="用例表"></a>用例表</h3><ul><li><u>用例表</u>一般由<strong>用例编号、用例名称、参与者、用例描述、前置条件、后置条件、正常流程和异常流程</strong>构成。</li></ul><table><thead><tr><th align="center">条目</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">用例编号</td><td align="center"><code>[数字]</code></td></tr><tr><td align="center">用例名称</td><td align="center"><code>[动宾结构]</code></td></tr><tr><td align="center">参与者</td><td align="center"><code>[主语]</code></td></tr><tr><td align="center">用例描述</td><td align="center"><code>[相互独立；可以观测]</code></td></tr><tr><td align="center">前置条件</td><td align="center"><code>[分点说明]</code></td></tr><tr><td align="center">后置条件</td><td align="center"><code>[分点说明]</code></td></tr><tr><td align="center">正常流程</td><td align="center"><code>[正常操作→正常结果]</code></td></tr><tr><td align="center">异常流程</td><td align="center"><code>[异常操作→异常结果]</code></td></tr></tbody></table><h2 id="功能性需求分析"><a href="#功能性需求分析" class="headerlink" title="功能性需求分析"></a><strong>功能性需求分析</strong></h2><h3 id="微服务API网关管理模块用例"><a href="#微服务API网关管理模块用例" class="headerlink" title="微服务API网关管理模块用例"></a>微服务API网关管理模块用例</h3><ul><li>下图为<u>微服务API网关管理模块的用例图</u>，其展示了在管理模块中，管理员用户作为参与者与用例之间的关系以及主用例和子用例之间的关系。根据分析，管理模块共有6个主要的用例，分别为<strong>用户登录、用户登出、管理用户、管理服务、管理应用和数据统计</strong>。</li></ul><p><img src="/images/admin_use_case.png" alt="微服务API网关管理模块用例图"></p><h3 id="微服务API网关核心模块用例"><a href="#微服务API网关核心模块用例" class="headerlink" title="微服务API网关核心模块用例"></a>微服务API网关核心模块用例</h3><ul><li>下图为<u>微服务API网关核心模块的用例图</u>，其展示了在核心模块中，普通用户作为参与者与用例之间的关系以及主用例和子用例之间的关系。根据分析，核心模块共有7个主要的用例，分别为<strong>协议接入、权限认证、流量统计、流量控制、请求重写、负载均衡和反向代理</strong>。</li></ul><p><img src="/images/core_use_case.png" alt="微服务API网关核心模块用例图"></p><h2 id="非功能性需求分析"><a href="#非功能性需求分析" class="headerlink" title="非功能性需求分析"></a><strong>非功能性需求分析</strong></h2><hr><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li><strong>对于用户操作而言</strong>：应用口令安全要求和会话超时机制</li><li><strong>对于请求访问而言</strong>：设置 <code>JWT</code> 校验和 <code>IP</code> 校验</li><li><strong>对于数据传输而言</strong>：启动 <code>HTTPS</code> 监听</li><li><strong>对于数据保存而言</strong>：敏感信息使用盐值加密并以密文方式入库</li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>选用性能表现优秀、功能支持齐全的框架 <code>Gin</code></li><li>先访问缓存 <code>Redis</code> 代替直接访问数据库 <code>MySQL</code></li></ul><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><ul><li><strong>故障时仍稳定服务</strong>：进行多实例部署，周期探活并故障重启</li><li><strong>容易横向扩展实例</strong>：弹性伸缩&amp;&amp;负载均衡</li></ul><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul><li>统一的 <code>RESTful API</code> 接口</li><li>直观的 <code>Vue-Element-Admin</code> 界面 </li></ul><h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a><strong>FAQs</strong></h2><blockquote><p><strong>Q：</strong>如何控制用例的粒度呢？</p><p><strong>A：</strong>参考<a href="https://www.cnblogs.com/HeroBeast/archive/2009/09/27/1575094.html" target="_blank" rel="noopener">用例的类型与粒度</a></p></blockquote><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a><strong>Refs</strong></h2><ul><li><a href="https://www.cnblogs.com/Yogurshine/archive/2013/01/14/2859248.html" target="_blank" rel="noopener">UML系列-用例图</a></li><li><a href="https://www.jianshu.com/p/7ff70e28bb72" target="_blank" rel="noopener">谈谈需求的描述-用例</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;u&gt;微服务API网关&lt;/u&gt;的&lt;strong&gt;需求分析&lt;/strong&gt;，分为&lt;strong&gt;两个&lt;/strong&gt;方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能性需求分析 - &lt;strong&gt;用例图和用例表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;非功能性需求分析&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Gorm# 思维导图：Gorm Object Relational Mapping Library</title>
    <link href="http://yoursite.com/2021/05/02/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8BGorm/"/>
    <id>http://yoursite.com/2021/05/02/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8BGorm/</id>
    <published>2021-05-01T23:00:21.000Z</published>
    <updated>2021-06-25T07:03:20.368Z</updated>
    
    <content type="html"><![CDATA[<p>备份记录 <code>Gorm</code> 的<strong>思维导图</strong>和<strong>相关文档</strong>。</p><hr><a id="more"></a><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h1><p><img src="/images/Gorm.png" alt="Gorm Mindmap"></p><h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a><strong>相关文档</strong></h1><ul><li><a href="https://learnku.com/docs/gorm/v2" target="_blank" rel="noopener">Gorm 中文文档</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;备份记录 &lt;code&gt;Gorm&lt;/code&gt; 的&lt;strong&gt;思维导图&lt;/strong&gt;和&lt;strong&gt;相关文档&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Mind Map" scheme="http://yoursite.com/categories/Mind-Map/"/>
    
    
    <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
    <category term="Gin" scheme="http://yoursite.com/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>#Gin# 思维导图：Gin Web Framework</title>
    <link href="http://yoursite.com/2021/05/01/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8BGin/"/>
    <id>http://yoursite.com/2021/05/01/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8BGin/</id>
    <published>2021-04-30T23:00:21.000Z</published>
    <updated>2021-06-25T06:53:21.881Z</updated>
    
    <content type="html"><![CDATA[<p>备份记录 <code>Gin</code> 的<strong>思维导图</strong>和<strong>相关文档</strong>。</p><hr><a id="more"></a><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h1><p><img src="/images/Gin.png" alt="Gin Mindmap"></p><h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a><strong>相关文档</strong></h1><ul><li><a href="https://learnku.com/docs/gin-gonic/2019" target="_blank" rel="noopener">Gin 框架中文文档</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;备份记录 &lt;code&gt;Gin&lt;/code&gt; 的&lt;strong&gt;思维导图&lt;/strong&gt;和&lt;strong&gt;相关文档&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Mind Map" scheme="http://yoursite.com/categories/Mind-Map/"/>
    
    
    <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
    <category term="Gin" scheme="http://yoursite.com/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 阅读《恒丰银行分布式核心系统 - API 网关 技术原型落地实践》笔记</title>
    <link href="http://yoursite.com/2021/04/07/%E6%81%92%E4%B8%B0%E9%93%B6%E8%A1%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%20-%20API%20%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF%E5%8E%9F%E5%9E%8B%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2021/04/07/%E6%81%92%E4%B8%B0%E9%93%B6%E8%A1%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%20-%20API%20%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF%E5%8E%9F%E5%9E%8B%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-04-06T23:00:21.000Z</published>
    <updated>2021-04-23T08:10:23.669Z</updated>
    
    <content type="html"><![CDATA[<p><em>赵毅,张涛.恒丰银行分布式核心系统-API网关技术原型落地实践[J].中国金融电脑,2017(04):48-55.</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><p><img src="/images/paper_xmind_5.png" alt="paper mindmap"></p><p>阅读本论文后，<strong>主要讨论以下两点</strong>：</p><ol><li>恒丰银行 API 网关技术架构</li><li>恒丰银行 API 网关设计亮点</li></ol><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a><strong>技术架构</strong></h2><p><img src="/images/paper_arch_5.png" alt="paper overall architecture"></p><p><img src="/images/paper_arch_6.png" alt="paper internal architecture"></p><ul><li><strong>Java SPI</strong>：实际是“基于接口的编程＋策略模式＋配置文件”的动态加载机制。</li><li><strong>Filter-PRPE</strong>：模型为 “PRE -&gt; ROUTING -&gt; POST -&gt; ERROR” 的责任链机制。</li></ul><p><img src="/images/config_data_structure.png" alt="config data structure design"></p><ul><li><strong>File System</strong>：提供了网关启动所需的环境配置信息，包括注册中心连接和参数配置、外部依赖连接和参数配置以及默认的基础规则配置。其中默认的基础规则配置可被动态地替换。</li><li><strong>Zookeeper</strong>：在提供服务注册与服务发现的能力之余，对配置进行持久化和订阅通知。</li></ul><blockquote><p><em>注：Zookeeper 替代了传统的数据库直接存储配置（MySQL 和 MongoDB 不再是必需的），Zookeeper 自带的消息订阅功能也解决了热更新问题（Redis 和 RabbitMQ 不再是必需的），为了提高运行效率数据将缓存在内存，这些都是非常具有参考价值的做法。同时，本文也提出了动态覆盖本地设置的新思路。</em></p></blockquote><h2 id="设计亮点"><a href="#设计亮点" class="headerlink" title="设计亮点"></a><strong>设计亮点</strong></h2><h3 id="多维度动态路由机制"><a href="#多维度动态路由机制" class="headerlink" title="多维度动态路由机制"></a>多维度动态路由机制</h3><p><img src="/images/route_rule_model.png" alt="route rule model"></p><p><img src="/images/multi-dimension_route_mechanism.png" alt="multi-dimension route mechanism"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>本文提出了一种基于 Java SPI + Filter PRPE 实现的微服务 API 网关的<strong>架构</strong>，在服务/配置数据动态管理和多维度动态路由机制这两个方面为毕设工作提供了宝贵的参考。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;赵毅,张涛.恒丰银行分布式核心系统-API网关技术原型落地实践[J].中国金融电脑,2017(04):48-55.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 阅读《微服务API网关的设计及应用》笔记</title>
    <link href="http://yoursite.com/2021/04/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/04/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-04-05T23:00:21.000Z</published>
    <updated>2021-04-22T13:46:32.754Z</updated>
    
    <content type="html"><![CDATA[<p><em>廖俊杰,陶智勇.微服务API网关的设计及应用[J].自动化技术与应用,2019,38(08):85-88.</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><p><img src="/images/paper_xmind_4.png" alt="paper mindmap"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>本文提出了一种基于 Spring Cloud Zuul 实现的微服务 API 网关的<strong>应用</strong>，侧重关注基于 Zuul 的实践使用而不是基于 Zuul 的二次设计，在技术栈的使用上也存在不同，故对毕设工作的帮助较少。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;廖俊杰,陶智勇.微服务API网关的设计及应用[J].自动化技术与应用,2019,38(08):85-88.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 阅读《基于 OpenResty 平台的 API 网关系统的设计与实现》笔记</title>
    <link href="http://yoursite.com/2021/04/05/%E5%9F%BA%E4%BA%8E%20OpenResty%20%E5%B9%B3%E5%8F%B0%E7%9A%84%20API%20%E7%BD%91%E5%85%B3%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/04/05/%E5%9F%BA%E4%BA%8E%20OpenResty%20%E5%B9%B3%E5%8F%B0%E7%9A%84%20API%20%E7%BD%91%E5%85%B3%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-04T23:00:21.000Z</published>
    <updated>2021-04-22T13:59:52.669Z</updated>
    
    <content type="html"><![CDATA[<p><em>温馨,樊婧雯,王富强.基于OpenResty平台的API网关系统的设计与实现[J].信息化研究,2020,46(03):62-68.</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><p><img src="/images/paper_xmind_3.png" alt="paper mindmap"></p><p>阅读本论文后，<strong>主要讨论以下两点</strong>：</p><ol><li>API 网关设计</li><li>API 网关实现</li></ol><h2 id="API-网关设计"><a href="#API-网关设计" class="headerlink" title="API 网关设计"></a><strong>API 网关设计</strong></h2><p><img src="/images/paper_arch_4.png" alt="paper architecture"></p><h3 id="API网关软件"><a href="#API网关软件" class="headerlink" title="API网关软件"></a>API网关软件</h3><ul><li><strong>读多</strong>，实现安全认证、流量控制、请求重写、反向代理、负载均衡和结果缓存等功能。</li></ul><h3 id="API网关监控管理中心"><a href="#API网关监控管理中心" class="headerlink" title="API网关监控管理中心"></a>API网关监控管理中心</h3><ul><li><strong>写多</strong>，实现服务配置、日志管理、系统监控、API管理等功能。</li></ul><blockquote><p><em>注：为实现数据的读写分离，提高网关的性能，网关不进行数据处理操作，数据处理由监控管理中心负责。</em></p></blockquote><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><ul><li>Redis：缓存配置和结果、分布式限流等</li><li>MongoDB：存储核心层的数据</li><li>MySQL：存储管理层和监控层的数据</li><li>Zookeeper：服务发现与服务注册</li></ul><blockquote><p><em>注：由于作者对数据同步和消息订阅没有详细展开讨论，个人直观感觉设计得有点过复杂了。</em></p><p><strong><u>本文的</u></strong>架构设计会涉及三次数据同步和消息订阅，一是 Zookeeper 和 MySQL 之间，二是 MySQL 和 MongoDB 之间，三是 MongoDB 和 Redis 之间。<strong><u>毕设的</u></strong>架构设计只涉及一次数据同步和消息订阅，即为 MySQL 和 Redis 之间。</p><ul><li>引入 Zookeeper 实现服务注册与服务发现，不可简化；MySQL 和 MongoDB 之间可以二者选一，MySQL 提供很好的事务性支持，MongoDB 更快速和易用，两者备份都有较成熟的方案；Redis 需要用作缓存与限流，不可简化。</li><li>Zookeeper 和 MySQL 之间可不同步，因为配置间有实体映射关系；MySQL 和 Redis 之间必须同步，以提高网关访问性能和实现配置热更新。</li></ul></blockquote><h2 id="API-网关实现"><a href="#API-网关实现" class="headerlink" title="API 网关实现"></a><strong>API 网关实现</strong></h2><p><img src="/images/paper_flowchart_2.png" alt="paper flowchart"></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>使用 Redis 作为全局的分布式计数器。</li><li>业务层面，设周期为 <code>t</code> 和 阈值为 <code>d</code>，则 TPS 为 <code>d/t</code>；技术层面，Redis 创建一个存储访问的键，设置过期时间为 <code>t</code>，当值达到 <code>d</code> 则触发自动告警或熔断降级。</li></ul><h3 id="服务兜底"><a href="#服务兜底" class="headerlink" title="服务兜底"></a>服务兜底</h3><ul><li>与流量控制相结合，保证上游的数据服务永不消失。</li><li>两种实现方式：一是触发限流后请求重定向到 <code>fallback</code> 过程中处理，可以主动发起二次请求获取兜底数据，这种做法需引入额外的回调逻辑，但数据和后端服务是保持一致的；二是从缓存中读取响应数据，这种做法不能保证数据一致，但是速度快且改动小。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>本文提出了一种基于 OpenResty 实现的微服务 API 网关的<strong>架构</strong>，在拆分服务、数据库的选型、数据同步和消息订阅这三个方面为毕设工作提供了宝贵的参考。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;温馨,樊婧雯,王富强.基于OpenResty平台的API网关系统的设计与实现[J].信息化研究,2020,46(03):62-68.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 阅读《Management of API Gateway Based on Micro-service Architecture》笔记</title>
    <link href="http://yoursite.com/2021/04/04/Management%20of%20API%20Gateway%20Based%20on%20Micro-service%20Architecture/"/>
    <id>http://yoursite.com/2021/04/04/Management%20of%20API%20Gateway%20Based%20on%20Micro-service%20Architecture/</id>
    <published>2021-04-03T23:00:21.000Z</published>
    <updated>2021-04-22T13:46:53.747Z</updated>
    
    <content type="html"><![CDATA[<p><em>Zhao, J &amp; Jing, S &amp; Jiang, L. (2018). Management of API Gateway Based on Micro-service Architecture. Journal of Physics: Conference Series. 1087. 032032. 10.1088/1742-6596/1087/3/032032.</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><p><img src="/images/paper_xmind_1.png" alt="paper mindmap"></p><p>阅读本论文后，<strong>主要讨论以下四点</strong>：</p><ol><li>应用架构图示及分析</li><li>身份认证令牌选择</li><li>信息加载的热更新解决方案</li><li>分布式的流量控制</li></ol><h2 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a><strong>应用架构</strong></h2><p><img src="/images/paper_arch_1.png" alt="paper architecture"></p><h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3><h4 id="Nginx-接入层"><a href="#Nginx-接入层" class="headerlink" title="Nginx 接入层"></a>Nginx 接入层</h4><ul><li>代理流量的统一入口。</li></ul><h4 id="Lua-脚本集"><a href="#Lua-脚本集" class="headerlink" title="Lua 脚本集"></a>Lua 脚本集</h4><ul><li>支持扩展各项中间件功能，如：权限认证、负载均衡、流量控制、存储日志、请求重写和反向代理等。与“管理服务-业务逻辑层”的功能相对应。</li></ul><h3 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h3><h4 id="API-接入层"><a href="#API-接入层" class="headerlink" title="API 接入层"></a>API 接入层</h4><ul><li>管理接口的统一入口。</li></ul><h4 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h4><ul><li>支持扩展各项业务层功能，如：接口配置信息、权限认证管理、流量控制管理、系统状态监控、系统数据统计和请求重写配置等。与“代理服务-Lua 脚本集”的功能相对应。</li></ul><h3 id="认证中心"><a href="#认证中心" class="headerlink" title="认证中心"></a>认证中心</h3><ul><li>用于提供 OAuth 2 + JWT 认证功能。</li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><ul><li>用于提供服务发现与服务注册功能。</li></ul><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><ul><li>作分布式限流的计数器；</li><li>缓存响应请求结果。</li></ul><h4 id="MySQL-集群"><a href="#MySQL-集群" class="headerlink" title="MySQL 集群"></a>MySQL 集群</h4><ul><li>主要用于存储流量控制信息。</li></ul><blockquote><p><em>注：作者没有进一步阐述为什么服务配置信息和流量控制信息要分开不同类型的数据库集群存储。</em></p></blockquote><h4 id="MongoDB-集群"><a href="#MongoDB-集群" class="headerlink" title="MongoDB 集群"></a>MongoDB 集群</h4><ul><li>主要用于存储服务配置信息。</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a><strong>身份认证</strong></h2><p><u><strong>本文将</strong></u>采用 OAuth 2 + JWT 组合。OAuth 2 引入了认证服务器和资源服务器的概念区分，OAuth 2 协议可以携带用户信息和权限信息的特征；JWT 是包含身份信息和过期时间的加密令牌，以减少数据库的访问。两者结合使用可以实现认证和鉴权。</p><p><img src="/images/oauth.png" alt="OAuth Auth"></p><p><u><strong>毕设将</strong></u>采用 JWT 令牌，出于简化的目的去除了 OAuth，更接近原文中所提及的 AppKeys ，也可以基本满足当前的需求。AppKeys 身份认证模式更适合开放服务的场景，它不涉及用户信息和权限信息。</p><p><img src="/images/appkeys.png" alt="AppKeys Auth"></p><h2 id="信息加载"><a href="#信息加载" class="headerlink" title="信息加载"></a><strong>信息加载</strong></h2><p><u><strong>本文的</strong></u>处理方式是：先从 Nginx Cache 中读，再从 MongoDB 中读，否则判断为非法的请求。Nginx 是自定义网关技术的常见基石；MongoDB 作为文档型数据库在修改服务配置信息上十分方便。</p><p><u><strong>毕设的</strong></u>处理方式是：先从 Redis 中读，再从 MySQL 中读，否则判断为非法的请求。Redis 是一个高性能的内存键值数据库，很适合用作为缓存；MySQL 作为关系型数据库，可以更好地抽象和管理服务信息、访问控制、负载均衡和租户信息等实体关系。</p><p>尽管如此，无论哪种方式都亟待去解决以下问题：</p><blockquote><p><em>MongoDB 更新之后如何刷新 Nginx Cache ？MySQL 更新之后如何刷新 Redis ？</em></p></blockquote><p>事实上，我们可以对这个问题进行抽象化：</p><blockquote><p>已知：A 服务写多读少，流量小；B 服务只读不写，流量大；C 数据由 A 服务写入数据库，由 A 服务或 B 服务读出数据库。</p><p>问题：<strong>如何使 A 服务和 B 服务之间保证 C 数据同步且一致（请求不能直接打到底层的数据库）呢？</strong></p><p><img src="/images/paper_flowchart_1.png" alt="paper flowchart"></p></blockquote><p>进行头脑风暴之后，解决的思路有：</p><ol><li><strong>管理服务同步更新代理服务</strong>：代理服务提供配置下发接口，管理服务变更时调用该接口，代理服务在内存中重新同步管理服务配置数据。缺点：代理服务和管理服务强耦合；配置下发性能损耗。</li><li><strong>管理服务异步更新代理服务</strong>：代理服务开启异步定时任务，管理服务直接变更，代理服务在内存中周期同步管理服务配置数据。缺点：数据一致性较差。</li><li><strong>MySQL 主从复制实现读写分离</strong>：主库写从库读，主库写时要解锁，从库读时不加锁。缺点：请求直接会打到数据库，并发要求可能被满足，但比内存数据库的请求时间会长。</li><li><strong>从 MySQL 同步数据至 Redis</strong>：增删改 MySQL 时，删除 Redis 对应的记录；查 Redis 时，如果命中立即返回，没有命中查 MySQL 并回写到 Redis。缺点：需要考虑缓存穿透、击穿和雪崩等问题。</li><li><strong>引入 RabbitMQ 解耦</strong>：观察与订阅的模式，生产者的 MySQL 发生改动时通知消费者的 Redis 也发生改动。缺点：又引进新组件，运维成本进一步地增大。</li><li><strong>使用 Consul 作为配置中心</strong>：Consul 既可以作为注册中心又可以作为配置中心，是分布式的键值型数据库。缺点：服务配置信息蕴含实体关系映射，不是配置中心的经典使用场景。</li></ol><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h2><p><strong><u>本文中</u></strong>使用 Redis 充当计数器来实现限流，适用于分布式的环境。</p><p><strong><u>毕设中</u></strong>可以采用官方原生库 <code>golang.org/x/time/rate</code> 或滴滴开源库 <code>github.com/didip/tollbooth</code>，仅适用单机版的环境。</p><p>显然，考虑到可扩展性，网关会以集群的形式进行部署，分布式限流是更为合理的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>本文提出了一种基于 Nginx + Lua 实现的微服务 API 网关的<strong>架构</strong>，在身份认证、信息加载和流量控制这三个方面为毕设工作提供了宝贵的参考。</p></blockquote><hr><p><em>致谢：<a href="https://github.com/yuqi657" target="_blank" rel="noopener">@lyq大佬</a>和<a href>@d师</a>对本文亦有贡献 :D</em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;Zhao, J &amp;amp; Jing, S &amp;amp; Jiang, L. (2018). Management of API Gateway Based on Micro-service Architecture. Journal of Physics: Conference Series. 1087. 032032. 10.1088/1742-6596/1087/3/032032.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Microservice# 阅读《浅析微服务架构 API 网关的作用》笔记</title>
    <link href="http://yoursite.com/2021/04/03/%E6%B5%85%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%20API%20%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2021/04/03/%E6%B5%85%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%20API%20%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2021-04-02T23:00:21.000Z</published>
    <updated>2021-04-22T13:46:26.857Z</updated>
    
    <content type="html"><![CDATA[<p><em>姚刚,吴海莉,王从镔.浅析微服务架构API网关的作用[J].信息系统工程,2020(12):16-18.</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><p><img src="/images/paper_xmind_2.png" alt="paper mindmap"></p><p>阅读本论文后，<strong>主要讨论以下两点</strong>：</p><ol><li>API 网关的架构</li><li>API 网关的选型</li></ol><h2 id="API-网关的架构"><a href="#API-网关的架构" class="headerlink" title="API 网关的架构"></a><strong>API 网关的架构</strong></h2><p><img src="/images/paper_arch_2.png" alt="paper architecture"></p><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><ul><li>Core（核心网关）系统的功能主要是对客户请求的接收， 它将请求指向给上层的服务端，并且会把这些处理结果返回给客户端或下层服务端。</li><li>可以以集群的形式部署，需要额外的负载均衡器，反向代理连接业务集群。</li><li><strong>可以实现核心的功能：</strong>认证鉴权、限流熔断、负载均衡、反向代理、服务编排、协议转换、日志记录、数据缓存、服务注册/发现和版本/灰度发布等。</li></ul><h3 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h3><ul><li>Admin（网关管理）系统负责配置系统的各种策略，如： 限流、缓存以及告警等基础信息。</li><li>可以以集群的形式部署，但是入口是统一的。</li><li><strong>可以实现管理的功能：</strong>API 单个管理、API 分组管理、SDK/文档生成、访问配置、流控配置、协议转换配置、数据缓存配置和监控告警配置等。</li></ul><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><ul><li>Monitor（监控日志） 系统负责生成运维管理报表等。</li><li>可以以集群的形式部署，采集可以多个节点进行。</li><li><strong>可以实现监控的功能：</strong>日志处理、生成报表和自动告警等。</li></ul><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><ul><li><p>管理库：记录管理信息</p></li><li><p>日志库：记录日志信息</p></li><li><p>Redis：缓存与限流</p></li><li><p>Zookeeper：服务注册与服务发现</p></li></ul><p><img src="/images/paper_arch_3.png" alt="paper architecture"></p><h3 id="OpenResty-API-Gateway"><a href="#OpenResty-API-Gateway" class="headerlink" title="OpenResty API Gateway"></a>OpenResty API Gateway</h3><ul><li>在 OpenResty API Gateway 中主要实现安全、限流、缓存、日志、监控和身份认证等功能，另外还可以实现制定服务的注册、路由重写和负载均衡等策略。</li></ul><h3 id="Aggr-API-Gateway"><a href="#Aggr-API-Gateway" class="headerlink" title="Aggr API Gateway"></a>Aggr API Gateway</h3><ul><li>在 Aggr API Gateway 中可 以使用超时、缓存、熔断、重试、查询聚合等策略。</li></ul><blockquote><p><em>注：作者没有进一步阐述为什么需要分成两个网关，即 OpenResty API Gateway 和 Aggr API Gateway。</em></p></blockquote><h2 id="API-网关的选型"><a href="#API-网关的选型" class="headerlink" title="API 网关的选型"></a><strong>API 网关的选型</strong></h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li>用户密码使用加盐 sha256 加密</li><li>租户密钥使用 Md5 加密</li></ul><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h4><ul><li>k8s 副本伸缩</li></ul><h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><ul><li>MySQL 和 Redis 做数据同步 </li></ul><h4 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h4><ul><li>MySQL 主从备份</li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><ul><li>gin</li></ul><h4 id="大流量"><a href="#大流量" class="headerlink" title="大流量"></a>大流量</h4><ul><li>限流、熔断、降级</li></ul><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ul><li>中间件的洋葱结构</li></ul><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p><img src="/images/api_life_cycle.png" alt="API Life Cycle"></p><ul><li>可参考 <a href="https://eng.uber.com/gatewayuberapi/" target="_blank" rel="noopener">Uber Edge Gateway</a> 的设计</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>本文提出了微服务 API 网关的通用设计架构，并指出在技术选型过程中需要考虑安全性、高可用、高性能、扩展性和生命周期管理等问题。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;姚刚,吴海莉,王从镔.浅析微服务架构API网关的作用[J].信息系统工程,2020(12):16-18.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Microservice" scheme="http://yoursite.com/categories/Microservice/"/>
    
    
    <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>#Others# 新移动设备的必要软件清单</title>
    <link href="http://yoursite.com/2021/03/15/%E6%96%B0%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%BF%85%E8%A6%81%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2021/03/15/%E6%96%B0%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%BF%85%E8%A6%81%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/</id>
    <published>2021-03-14T23:00:21.000Z</published>
    <updated>2021-05-09T07:06:56.836Z</updated>
    
    <content type="html"><![CDATA[<p>备份记录新移动设备的<strong>必要软件清单</strong>：To C / To B</p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="To-C"><a href="#To-C" class="headerlink" title="To C"></a><strong>To C</strong></h2><h3 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h3><ul><li>微信：手机/平板</li><li>TIM：手机/平板</li></ul><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><ul><li>QQ音乐：手机/平板</li><li>微信读书：手机/平板</li><li>豆瓣：手机</li><li>懂球帝：手机</li><li>微博：手机</li><li>哔哩哔哩：平板</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li>美团：手机</li><li>高德地图：手机</li><li>携程：手机</li><li>Keep：平板</li></ul><h3 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h3><ul><li>京东：手机</li><li>淘宝：平板</li></ul><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ul><li>牛客：平板</li><li>超级简历：平板</li><li>力扣：平板</li><li>V2EX：手机</li><li>知乎：手机</li><li>极客时间：平板</li><li>慕课网：平板</li></ul><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><ul><li>招商银行：手机</li><li>招商证券：手机</li><li>支付宝：手机</li><li>理财通：手机</li><li>火币：手机</li><li>币安：手机</li><li>同花顺投资账本：平板</li><li>鲨鱼记账：平板</li></ul><h2 id="To-B"><a href="#To-B" class="headerlink" title="To B"></a><strong>To B</strong></h2><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul><li>企业微信：手机</li><li>腾讯会议：手机</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>百度网盘：手机</li><li>OneDrive：平板</li></ul><h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><ul><li>腾讯文档：手机</li><li>Office 365：平板</li><li>Office Lens：平板</li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>OneNote：平板</li><li>MarginNote：平板</li></ul><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><ul><li>MOA：手机</li><li>RDM：手机</li><li>乐问：手机</li><li>脉脉：手机</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>To Do：手机/平板</li><li>v2rayNG：手机</li><li>Forest：手机/平板</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;备份记录新移动设备的&lt;strong&gt;必要软件清单&lt;/strong&gt;：To C / To B&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Others" scheme="http://yoursite.com/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>#Others# 重装系统后的必要软件清单</title>
    <link href="http://yoursite.com/2021/03/15/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E5%BF%85%E8%A6%81%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2021/03/15/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E5%BF%85%E8%A6%81%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/</id>
    <published>2021-03-14T23:00:21.000Z</published>
    <updated>2021-07-16T16:23:41.230Z</updated>
    
    <content type="html"><![CDATA[<p>备份记录重装系统后的<strong>必要软件清单</strong>：开发 / 办公 / 实用</p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a><strong>开发</strong></h2><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li>Notepad++：查看文本文件</li><li>Typora：查看 Markdown 文件</li><li>VSCode：查看代码文件</li></ul><h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3><ul><li>Golang</li><li>Flutter</li><li>Node.js</li><li>Python</li></ul><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h4 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a>JetBrains</h4><ul><li>JetBrains GoLand</li><li>JetBrains PyCharm</li><li>JetBrains 插件<ul><li>Git Tool Box：查看Git提交的记录</li><li>PreCI：本地扫描腾讯代码规范</li></ul></li></ul><h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><ul><li><p>Flutter 支持和检查</p></li><li><p>Node.js 支持和检查</p></li><li><p>VSCode 插件</p><ul><li>GitLens：查看Git提交的记录</li><li>PreCI：本地扫描腾讯代码规范</li><li>Chinese (Simplified) Language Pack for Visual Studio Code：中文显示</li><li>GBKtoUTF8：中文编码</li><li>Open In Browser：在浏览器打开 HTML 文件</li><li>Debugger for Chrome：在 Chrome 浏览器进行调试</li><li>Document This：支持快捷注释</li><li>Todo Tree：查看待办事项列表</li><li>Markdown All in One &amp; Markdown Lint &amp; Markdown Preview Github Styling &amp; Markdown TOC：Markdown支持&amp;检查&amp;渲染&amp;目录</li><li>PlantUML：绘制 UML 图表</li><li>Docker：管理 docker 镜像和容器等</li><li>Remote - WSL：远程连接 WSL 进行开发</li></ul></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>MySQL</li><li>Redis</li><li>SQLite</li></ul><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><ul><li>Windows Terminal：连接本地服务器</li><li>XShell：连接远程服务器</li><li>HeidiSQL：连接远程 MySQL 数据库</li><li>RDM：连接远程 Redis 数据库</li></ul><h3 id="虚拟系统"><a href="#虚拟系统" class="headerlink" title="虚拟系统"></a>虚拟系统</h3><ul><li>Ubuntu WSL</li><li>Alpine WSL</li></ul><h3 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h3><ul><li><p>Git：版本控制</p></li><li><p>swaggo：接口文档</p></li><li><p>Postman &amp; Newman：接口测试</p></li></ul><h3 id="公司使用"><a href="#公司使用" class="headerlink" title="公司使用"></a>公司使用</h3><ul><li>iOA</li><li>WeTERM</li><li>iFit</li><li>腾讯电脑管家</li></ul><h2 id="办公"><a href="#办公" class="headerlink" title="办公"></a><strong>办公</strong></h2><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul><li>微信</li><li>企业微信</li><li>TIM</li><li>Telegram</li><li>腾讯会议</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>企业云盘</li><li>OneDrive</li><li>百度网盘</li></ul><h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><ul><li>Office 365</li><li>Office Lens</li><li>Drawboard PDF</li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>OneNote</li><li>XMind</li></ul><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><ul><li>StarUML</li><li>MockPlus</li></ul><h2 id="实用"><a href="#实用" class="headerlink" title="实用"></a><strong>实用</strong></h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>Bing壁纸：更换桌面和锁屏壁纸</li><li>Edge：微软浏览器</li><li>Chrome：谷歌浏览器</li><li>WinRar：解压/压缩工具，主要格式：.zip/.rar</li><li>7-Zip：解压/压缩工具，主要格式：.tar</li><li>FormatFactory：转换各种格式</li></ul><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><ul><li>To Do：待办事项</li><li>Sticks：桌面便签</li></ul><h3 id="便捷"><a href="#便捷" class="headerlink" title="便捷"></a>便捷</h3><ul><li>Everything：搜索工具</li><li>TreeSize：查空间工具</li><li>Snipaste：截图工具</li><li>Ditto：剪切板工具</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;备份记录重装系统后的&lt;strong&gt;必要软件清单&lt;/strong&gt;：开发 / 办公 / 实用&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Others" scheme="http://yoursite.com/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>#Sucks# 写在二零二壹</title>
    <link href="http://yoursite.com/2021/01/01/%E5%86%99%E5%9C%A8%E4%BA%8C%E9%9B%B6%E4%BA%8C%E5%A3%B9/"/>
    <id>http://yoursite.com/2021/01/01/%E5%86%99%E5%9C%A8%E4%BA%8C%E9%9B%B6%E4%BA%8C%E5%A3%B9/</id>
    <published>2020-12-31T16:00:00.000Z</published>
    <updated>2021-02-25T02:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>（（（假装有简介.jpg</p><hr><a id="more"></a><p>过去的一年其实还蛮糟糕的（或者说下半年，但是也发生了很多美好的事情。因为很长一段时间都不写作了，感觉到既遗憾又气愤，所以这不会是一篇好随感，索性就像每日面对的客体一样，整齐划一地理清我的思绪。</p><blockquote><p><strong>2020 糟糕的事情：</strong></p><ul><li>做了一些无用功，并且最后也处理得不好</li><li>工作的时候学习变得零碎，休息的时候缺乏学习热情</li><li>身体感觉不好，作息不够规律，职业病少运动，摄入过多酒精</li><li>对事物开始冷感，不阅读不写作</li><li>工作的时候很自闭，休息的时候很肥宅</li><li>最近有点本末倒置，害怕看到了尽头</li><li>感觉自己有点病了，失去了生命力</li></ul><p><strong>2020 美好的事情：</strong></p><ul><li>王小葵和王银河</li><li>春招的 offer 收割机（bushi，对自己的一点点的肯定</li><li>拿到了满意的 offer，妈宝的胜利（逃</li><li>开始学习理财知识，一场有趣的游戏</li></ul></blockquote><p>总的来说，我讨厌 2020 原地踏步甚至拼命倒退的自己，并且这种想法还会越来越少，自己也不愿意走出舒适圈。与此同时，我感到灵魂中，已经少了许多纯粹，反而添了许多欲望。2021 希望自己健健康康、开开心心。</p><blockquote><p><strong>2021 Todo List：</strong></p><ul><li>重视身体情况，早睡早起，晚上回来可以做做运动，养生</li><li>午休前和睡觉前都可以读读书，多看电影多听新歌，坚持写日记</li><li>养成每天开始工作前关注新技术，结束工作后总结这一天的好习惯</li><li>周末要出去走走，要学习知识</li><li>工作时间不要分心其它事情，做好时间管理</li><li>和别人交往善良和热情，如果需要练习那么就去练习，但也要有自己的原则</li><li>不要拖延，想就去做，每天记录自己好的变化</li><li>希望新的一年除了工作以外，有一些新的关注点</li></ul></blockquote><p>Hope is a dangerous thing for a woman like me to have. Fake it till you make it.</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;（（（假装有简介.jpg&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Sucks" scheme="http://yoursite.com/categories/Sucks/"/>
    
    
  </entry>
  
  <entry>
    <title>#Mock# Challenge to Mock - Tech Details</title>
    <link href="http://yoursite.com/2020/12/17/Challenge%20to%20Mock%20-%20Tech%20Details/"/>
    <id>http://yoursite.com/2020/12/17/Challenge%20to%20Mock%20-%20Tech%20Details/</id>
    <published>2020-12-16T23:00:21.000Z</published>
    <updated>2021-03-09T08:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>God is a mock. <em>– Just Kidding</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><blockquote><p>最近接到了新任务——希望 mock 掉项目依赖的底座，主要基于两点考量：</p><ul><li>内部联调时可以屏蔽掉底座的影响，不至于阻塞当前开发模块的流程；</li><li>之后可集成自动化测试，降低测试成本。</li></ul><p>我的第一感觉是这个东西不好搞。一是上下游的依赖关系比较复杂，这意味着：首先让 mock 做到可以替换原来的底座以满足基本功能就需要一些努力，其次项目“看起来”运行正常并不能保证上游亦是如此；二是替换底座包含了 mock 掉数据返回和状态管理两个概念，那么就不得不在简洁和可用之间做取舍了。</p><p>前文已经展开讨论了业务分析和架构演化这两方面的内容，本文将整理一些技术细节。</p></blockquote><hr><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h2><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><ul><li><strong>优点</strong>：<ol><li>界面化操作，比较直观</li><li>可以集成 Postman 各种功能，如接口文档、接口测试等</li></ol></li><li><strong>缺点</strong>：<ol><li>设置匹配规则不够灵活</li><li>返回数据自定义不方便</li><li>所有用例都在一个文件，不好进行版本管理</li></ol></li></ul><h3 id="web-framework"><a href="#web-framework" class="headerlink" title="web framework"></a>web framework</h3><ul><li><strong>优点</strong>：<ol><li>由于是自己来实现功能，非常灵活</li></ol></li><li><strong>缺点</strong>：<ol><li>重新造很多轮子，工作量大</li></ol></li></ul><h3 id="json-server-Mock-js"><a href="#json-server-Mock-js" class="headerlink" title="json-server + Mock.js"></a>json-server + Mock.js</h3><ul><li><strong>优点</strong>：<ol><li>框架轻量且容易上手</li><li>json-server用于设置转发规则，mock.js用于模拟返回数据，分工明确</li></ol></li><li><strong>缺点</strong>：<ol><li>二次开发有语言壁垒</li></ol></li></ul><h3 id="内部框架"><a href="#内部框架" class="headerlink" title="内部框架"></a>内部框架</h3><ul><li><strong>优点</strong>：<ol><li>转发规则和返回数据在同一模板文件中约定</li><li>内置了常用的工具函数，并且支持存根注入来扩展功能</li><li>非单一的 mock 框架，支持契约测试</li></ol></li><li><strong>缺点</strong>：<ol><li>存根入口单一，复用存根不太方便</li><li>请求参数匹配支持较弱</li></ol></li></ul><blockquote><p>总结：选用内部框架更符合当前的场景。</p></blockquote><h2 id="接口文档-接口测试"><a href="#接口文档-接口测试" class="headerlink" title="接口文档 / 接口测试"></a><strong>接口文档 / 接口测试</strong></h2><h3 id="Postman-Newman"><a href="#Postman-Newman" class="headerlink" title="Postman + Newman"></a>Postman + Newman</h3><ul><li><strong>优点</strong>：<ul><li>界面化操作，比较直观</li><li>独立于代码之外，无侵入</li><li>接口测试比较强大，支持设置顺序、次数、运行测试前执行脚本和运行测试后进行判断等功能</li></ul></li><li><strong>缺点</strong>：<ul><li>生成的接口文档只能在线查看，无法本地保存</li><li>文档可定制化的部分较少，无法对输入输出字段做备注</li></ul></li></ul><h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><ul><li><strong>优点</strong>：<ul><li>生成的文档信息齐全，包括路径、请求参数及描述、返回数据及描述以及示例等</li><li>直接在代码中标记，可以培养一边开发一边写文档的好习惯</li><li>配置后还可以直接发送请求测试接口</li></ul></li><li><strong>缺点</strong>：<ul><li>接口测试功能比较单一，无法很方便地管理一个功能集合层面的测试用例</li></ul></li></ul><blockquote><p>总结：如果看重文档输出，使用 Swagger；如果看重接口测试，使用 Postman + Newman。如果是在开发过程中，使用 Swagger，持续集成；如果是在开发过程后，使用 Postman + Newman，最少改动。其实最佳实践应该是两者结合起来使用，唯一的缺点就是工作量比较大。</p></blockquote><h2 id="进程部署-容器部署"><a href="#进程部署-容器部署" class="headerlink" title="进程部署 / 容器部署"></a><strong>进程部署 / 容器部署</strong></h2><ul><li><p>分别提供两种模式的部署脚本，前置知识：</p><ul><li><a href="https://lottewong.github.io/2020/05/14/速查手册之常用Linux&Shell命令/" target="_blank" rel="noopener">#Linux&amp;Shell# 速查手册：常用 Linux&amp;Shell 命令</a></li><li><a href="https://lottewong.github.io/2020/05/21/速查手册之常用Docker命令/" target="_blank" rel="noopener">#Docker# 速查手册：常用 Docker 命令</a></li><li><a href="https://lottewong.github.io/2020/05/28/速查手册之常用Kubernetes命令/" target="_blank" rel="noopener">#Kubernetes# 速查手册：常用 Kubernetes 命令</a></li></ul></li></ul><h2 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a><strong>代办事项</strong></h2><ul><li>完善单元测试</li><li>精简镜像大小</li><li>接入 CI / CD 流水线</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h2><ul><li><a href="https://insights.thoughtworks.cn/about-contract-test/" target="_blank" rel="noopener">聊一聊契约测试</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;God is a mock. &lt;em&gt;– Just Kidding&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="QA" scheme="http://yoursite.com/categories/QA/"/>
    
    
    <category term="Mock" scheme="http://yoursite.com/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>#Mock# Challenge to Mock - Arch Designs</title>
    <link href="http://yoursite.com/2020/12/16/Challenge%20to%20Mock%20-%20Arch%20Designs/"/>
    <id>http://yoursite.com/2020/12/16/Challenge%20to%20Mock%20-%20Arch%20Designs/</id>
    <published>2020-12-15T23:00:21.000Z</published>
    <updated>2021-03-09T08:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>God is a mock. <em>– Just Kidding</em></p><hr><a id="more"></a><h1 id="目录-Table-of-Contents"><a href="#目录-Table-of-Contents" class="headerlink" title="目录 Table of Contents"></a><strong>目录 Table of Contents</strong></h1><!-- toc --><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><blockquote><p>最近接到了新任务——希望 mock 掉项目依赖的底座，主要基于两点考量：</p><ul><li>内部联调时可以屏蔽掉底座的影响，不至于阻塞当前开发模块的流程；</li><li>之后可集成自动化测试，降低测试成本。</li></ul><p>我的第一感觉是这个东西不好搞。一是上下游的依赖关系比较复杂，这意味着：首先让 mock 做到可以替换原来的底座以满足基本功能就需要一些努力，其次项目“看起来”运行正常并不能保证上游亦是如此；二是替换底座包含了 mock 掉数据返回和状态管理两个概念，那么就不得不在简洁和可用之间做取舍了。</p><p>本文接下来要讨论的内容，暂不考虑上游影响，并坚持这样的原则：整个模块应当是轻量的，仅对高优先级且不满足的业务场景做出适配。</p></blockquote><hr><h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a><strong>业务分析</strong></h2><p><img src="/images/business_analysis.png" alt="项目架构"></p><h3 id="project-service"><a href="#project-service" class="headerlink" title="project service"></a>project service</h3><ul><li><strong>api</strong>：同步的项目入口，直接发请求或开异步任务来调用底座</li><li><strong>job</strong>：异步的后台任务，监控底座资源状态</li><li><strong>db</strong>：存储项目所需的数据</li></ul><h3 id="infrastructure-base"><a href="#infrastructure-base" class="headerlink" title="infrastructure base"></a>infrastructure base</h3><ul><li>提供核心功能的底座</li></ul><h3 id="external-services"><a href="#external-services" class="headerlink" title="external services"></a>external services</h3><ul><li>出于其它业务需求，会存储底座的某些数据</li></ul><blockquote><p>根据上图的分析，需考虑以下几点：</p><ol><li><p>mock 可以代替 infrastructure base 正常响应；</p></li><li><p>project service / infrastructure bases / external services 三者之间的数据应当保持一致性；</p></li><li><p>异步的后台任务需要监控状态变化，保存状态是必需的。</p></li></ol></blockquote><h2 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a><strong>架构演化</strong></h2><h3 id="固定数据"><a href="#固定数据" class="headerlink" title="固定数据"></a>固定数据</h3><blockquote><p><strong>问题描述</strong>：mock 从无到有</p><p><strong>解决方法</strong>：选用预研的框架，可以方便地管理路由转发规则和模拟返回数据</p></blockquote><p><img src="/images/arch_design_1.png" alt="架构演化-固定数据"></p><ul><li><strong>mock api proxy</strong>：设置路由转发规则。应该采用正则匹配，保证增删查改的通用性，预研框架支持：<ul><li>请求路径正则匹配</li><li>请求参数正则匹配</li><li>请求主体正则匹配</li></ul></li><li><strong>hardcoded response</strong>：提供对应路由的返回数据。应该返回全量的响应字段，其中一些字段可以灵活处理：<ul><li>UUID：创建资源时返回随机 UUID；查询/修改/删除单个资源时从路径读 UUID；查询资源列表时返回固定条目和 UUID</li><li>其它字段：必传字段从请求中接收；选传字段硬编码其内容；如果出现不同响应格式，路由转发规则要做区分</li></ul></li></ul><h3 id="引入存根"><a href="#引入存根" class="headerlink" title="引入存根"></a>引入存根</h3><blockquote><p><strong>问题描述</strong>：需要对返回字段做逻辑处理，固定数据模式无法直接满足</p><p><strong>解决方法</strong>：预研框架支持存根注入，保留了扩展业务逻辑的能力</p></blockquote><p><img src="/images/arch_design_2.png" alt="架构演化-引入存根"></p><ul><li><p><strong>easy stub</strong>：支持简易逻辑扩展，主要可以用于：</p><ul><li>提供配置</li><li>提取、组合和处理请求的数据</li><li>返回随机数据或当前时间等</li></ul><p><em>注：在预研框架中，存根的入口是唯一的，因此如果希望复用多个存根，方式不太优雅。</em></p></li></ul><h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><blockquote><p><strong>问题描述</strong>：目前的架构中没有办法保存数据，无法实现保持数据的一致性和监控状态变化</p><p><strong>解决办法</strong>：引入 MVC 设计和轻量级的数据库 SQLite</p></blockquote><p><img src="/images/arch_design_3.png" alt="架构演化-存储数据"></p><ul><li><strong>service stub</strong>：MVC 中的 Controller</li><li><strong>dao</strong>：MVC 中的 Model</li><li><strong>sqlite</strong>：轻量级关系型数据库，支持单文件和内存两种存储模式</li></ul><h3 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h3><blockquote><p><strong>问题描述</strong>：预研框架对通过请求参数匹配的支持较弱，infrastructure base A 没有相关需求，infrastructure base B 需解决该问题</p><p><strong>解决办法</strong>：只能引入轻量的 Web 框架来补充</p></blockquote><p><img src="/images/arch_design_4.png" alt="架构演化-参数匹配"></p><ul><li><p><strong>query matcher</strong>：强化请求参数匹配规则的核心中间件/装饰器</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchingMode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line"> Has = <span class="hljs-string">"has"</span>  <span class="hljs-comment"># 模糊匹配</span></span><br><span class="line"> Is = <span class="hljs-string">"is"</span>  <span class="hljs-comment"># 精确匹配</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryMatcher</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, matching_rules, query_arguments, matching_mode)</span>:</span></span><br><span class="line">     self.matching_rules = matching_rules</span><br><span class="line">     self.query_arguments = query_arguments</span><br><span class="line">     self.matching_mode = matching_mode</span><br><span class="line"></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">match</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">     <span class="hljs-comment"># 检查请求参数的数量</span></span><br><span class="line">     <span class="hljs-keyword">if</span> self.matching_mode == MatchingMode.Is:</span><br><span class="line">         <span class="hljs-keyword">if</span> len(self.matching_rules) != len(self.query_arguments):</span><br><span class="line">             logger.debug(<span class="hljs-string">"match failed: length of query arguments is not equal to length of the matching rule"</span>)</span><br><span class="line">             <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">     <span class="hljs-comment"># 检查请求参数的规则</span></span><br><span class="line">     <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.matching_rules:</span><br><span class="line">         <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.query_arguments:</span><br><span class="line">             rule = self.matching_rules[key]</span><br><span class="line">             val = str(self.query_arguments[key][<span class="hljs-number">0</span>])</span><br><span class="line">             <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> re.match(rule, val):</span><br><span class="line">                 logger.debug(<span class="hljs-string">"match failed: query argument not match matching rule. rule: %s, val: %s"</span> % (rule, val))</span><br><span class="line">                 <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">         <span class="hljs-keyword">else</span>:</span><br><span class="line">             logger.debug(<span class="hljs-string">"match failed: query argument not in matching rules"</span>)</span><br><span class="line">             <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">     <span class="hljs-comment"># 均通过则返回真</span></span><br><span class="line">     <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="统一配置"><a href="#统一配置" class="headerlink" title="统一配置"></a>统一配置</h3><blockquote><p><strong>问题描述</strong>：由于同时存在两套框架及一些业务数据，配置比较分散</p><p><strong>解决办法</strong>：将这些配置统一到一个文件，并在文档上说明约束是有必要的</p></blockquote><p><img src="/images/arch_design_5.png" alt="架构演化-统一配置"></p><ul><li><p><strong>config</strong>：统一的配置文件</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"host"</span>: <span class="hljs-string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="hljs-attr">"mock_port"</span>: <span class="hljs-number">1024</span>,</span><br><span class="line">  <span class="hljs-attr">"web_port"</span>: <span class="hljs-number">2333</span>,</span><br><span class="line"></span><br><span class="line">  <span class="hljs-attr">"db_name"</span>: <span class="hljs-string">"test.db"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="hljs-attr">"mock_config_path"</span>: <span class="hljs-string">"etc/mock_config.yml"</span>, <span class="hljs-comment">// 其中还可以配置日志的路径</span></span><br><span class="line">  <span class="hljs-attr">"web_config_path"</span>: <span class="hljs-string">"etc/web_config.json"</span>, <span class="hljs-comment">// 其中还可以配置日志的路径</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-attr">"business_field_1"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"business_field_2"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"business_field_3"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><blockquote><p><strong>问题描述</strong>：预研框架自带日志记录，但是新引入的 Web 框架没有</p><p><strong>解决办法</strong>：需要自行补充日志模块</p></blockquote><p><img src="/images/arch_design_6.png" alt="架构演化-日志记录"></p><ul><li><p><strong>log</strong>：补充的日志模块</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="hljs-section">[formatter_web]</span></span><br><span class="line"><span class="hljs-attr">format</span>=%(asctime)s|%(name)s|%(levelname)s|%(filename)s|%(funcName)s|%(message)s</span><br><span class="line"><span class="hljs-attr">datefmt</span>=</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><blockquote><p><strong>问题描述</strong>：部署 mock 后不好快速简单地验证是否可用</p><p><strong>解决办法</strong>：额外增加两个专门用于健康检查的接口</p></blockquote><p><img src="/images/arch_design_7.png" alt="架构演化-健康检查"></p><ul><li><p><strong>h-c</strong>：健康检查接口（Health-Check API），可参考的设计：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="hljs-string">'http://$&#123;ip&#125;:&#123;port&#125;/mock/ping'</span> <span class="hljs-comment"># Expected response body: &#123;"msg": "pong"&#125;</span></span><br><span class="line"></span><br><span class="line">curl --location --request GET <span class="hljs-string">'http://$&#123;ip&#125;:&#123;port&#125;/web/ping'</span> <span class="hljs-comment"># Expected response body: &#123;"msg": "pong"&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="预告"><a href="#预告" class="headerlink" title="预告"></a><strong>预告</strong></h2><blockquote><p><a href="https://lottewong.github.io/2020/12/16/Challenge%20to%20Mock%20-%20Tech%20Details/" target="_blank" rel="noopener">下期</a>将继续讨论以下这些内容：</p><ul><li>技术选型</li><li>接口文档 / 接口测试</li><li>进程部署 / 容器部署</li><li>代办事项</li></ul></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;God is a mock. &lt;em&gt;– Just Kidding&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="QA" scheme="http://yoursite.com/categories/QA/"/>
    
    
    <category term="Mock" scheme="http://yoursite.com/tags/Mock/"/>
    
  </entry>
  
</feed>
